## Линейные алгоритмы
### Что такое линейный алгоритм?

* Под линейными алгоритмами будем подразумевать алгоритмы такие, для написания которых нам достаточно только одного цикла. 
* Линейные алгоритмы, как правило, эффективны. Часто на их выполнение тратится столько же времени, сколько на считывание входных данных.
* Асимптотически сложность таких алгоритмов всегда оценивается как $O(n)$
  <details>
    <summary><b>Что это значит?</b></summary>
    Простыми словами, время выполнения такого алгоритма будет прямо пропорционально размеру данных, с которыми необходимо работать.

    Подробней про асимптотику и O-нотации можно узнать в [этом]() уроке.
  </details>

### Сумма элементов массива

Для лучшего понимания давайте посмотрим на код, при помощи которого можно найти сумму элементов массива.

Вам должен быть уже хорошо знаком принцип работы такого алгоритма: мы заводим переменную sum, значение которой изначально равно 0, а затем поочередно добавляем к ней каждый элемент массива (или списка в языке python).

Реализация для Python
```python
a = [3, 4, 5, 8]
sum = 0
for i in range(len(a)):
    sum += a[i]
print(sum)    
```
Реализация для c++
```cpp
int a[4] = {3, 4, 5, 8};
int sum = 0;
for(int i = 0; i < 4; i++){
    sum += a[i];
}
cout << sum;
```

Но даже у такого простого алгоритма могут возникать свои нюансы.

> **Важно**: 
> * Не забывайте присваивать значение "0" переменной sum в начале работы программы. Если забыть это сделать в с++, то переменная останется неинициализированной, и сумма будет принимать странные значения
> * Помните про переполнения. Число типа данных int вмещает в себя значение до $2^31-1$. Если сумма элементов в какой-то момент станет больше, то случится переполнение и результат окажется некорректным

### Максимум и минимум в массиве
### Индекс максимума
### Второй максимум (и его индекс)
### Частичные суммы: что это?
### Массив частичных сумм
### Массив частичных сумм: N-мерный случай**
### Подотрезок с максимальной суммой**

> Подотрезком будем называть множество, состоящее из нескольких подряд идущих элементов массива.
> Более формально, если у нас есть массив [$a_1, a_2, \dots, a_n$], то его подотрезком будет любой массив вида [$a_k, a_{k+1}, \dots, a_l$], где $1 \le k \le l \le n$.
> 
> Например, для массива [$4, 3, 2, 5$] подотрезками будут являться [$3, 2$], [$4$], [$3, 2, 5$].

Задача формулируется следующим образом: для данного массива нужно найти подотрезок, сумма элементов которого максимальна.

* Понятно, что если в нашем массиве все элементы неотрицательны, то в качестве такого подотрезка можно взять весь массив.

  Мы можем так поступить, поскольку при добавлении в сумму еще одного элемента она либо убеличится, либо не изменится.

  Например, для массива [$1, 2, 3, 4$] максимальная достижимая сумма на подотрезке --- $10$, и это же --- сумма вех элементов.
* Но что делать, если в массиве содержатся отрицательные элементы? Для массива [$5, 2, -20, 4, 1$] сумма всех его элементов будет равна $-8$, а сумма на подотрезке [$5, 2$] --- $7$, что явно больше.

Для начала приедем упрощенное решение этой задачи. Будем искать только максимальную сумму, без границ подотрезка, на котором она достигается.



### Бонус

В языке Python для некоторых линейных алгоритмов существуют встроенные функции.
```python
a = [5, 6, 7, 8, 2, 1]
print(sum(a)) # Выведет сумму элементов массива: 29
print(max(a)) # Выведет максимальный элемент списка: 8
print(min(a)) # Выведет минимальный элемент списка: 1
```
Помимо этого, существует удобный способ сокращать код до одной строки!

Для этого воспользуемся генераторами списков. Например, алгоритм, выводящий список, состоящий из всех элементов массива a, умноженных на 3, можно записать следующим образом

```python
a = [1, 2, 3]
print([3 * element for element in a])
```