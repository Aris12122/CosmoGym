### Работа с символами

В следующих задачах нам будет полезен такой тип данных, как char. Он предназначен для хранения одного символа и занимает 1 байт памяти. 

Каждому символу соответствует 8-битное целое значение – ASCII-код. Таким образом тип char может использоваться для хранения целых чисел от -128 до 127 или от 0 до 255 (в зависимости от того, какой из типов используется: signed char и unsigned char).

Рассмотрим коды наиболее интересных нам символов:

* '0'..'9' – цифры в формате символов (ASCII-коды: 48-57)

* 'A'..'Z' – заглавные (прописные) латинские буквы (ASCII-коды: 65-90)

* 'a'..'z' – маленькие (строчные) латинские буквы (ASCII-коды: 97-122)

Символьные переменные сравнимы согласно значениями их ASCII-кодов. При использовании совместно с целыми типами возможно приведение от одного типа к другому согласно ASCII.

#### Явное приведение к типу данных в с++

Чтобы привести переменную $x$, например, к типу данных int, мы можем использовать два следующих способа записи, которые дают аналогичный результат:

```cpp
cout << int(x) << endl; // функциональный стиль
cout << (int)x << endl; // старый стиль
```

#### Работа с кодом символа

Чтобы получить ASCII-код символа в языке с++, необходимо привести его к типу данных int.
```cpp
char symb = 'a';
cout << int(symb) << endl; // 97
```

В языке Python для этого необходимо использовать функцию ord().
```python
symb = 'a'
print(ord(symb)) # 97
```
Можно сделать и **обратное**: зная код, получить сам символ.

В языке c++ необходимо записать код символа в переменную типа char, а затем явным образом привести к типу char.
```cpp
char symb = 97;
cout << char(symb) << endl; // a
```

В языке Python необходимо использовать функцию chr().
```python
symb = 97
print(chr(symb)) # a
```

#### Номер буквы в алфавите

Наиболее часто встречающаяся работа с символами &mdash; поиск порядкового номера буквы в алфавите (будем считать, что буквы пронумерованы от $0$ до $25$).

Дело в том, что буквы в таблице ASCII расположены в алфавитном порядке. Поэтому, например, чтобы узнать номер буквы \text{'t'}, достаточно узнать, насколько далеко она расположена от буквы a. Другими словами, необходимо получить разность кодов букв a и t.

В языке с++ удобно пользоваться упрощенным способом записи, при котором компилятор производит неявные (не видимые) преобразования типов.
```cpp
cout << int('t') - int('a') << endl; // вычислим разность кодов букв и получим 19
cout << 't' - 'a' << endl; // упрощенный способ записи, также даст 19
```

В языке Python упрощенный способ записи работать не будет, так как 't' и 'a' он воспринимает как строки, а не как символы.

```python
print(ord('t') - ord('a')) # 19
```
Опять же, можно решить **обратную задачу**: по номеру буквы в алфавите получить саму букву.

В с++:
```cpp
cout << char(int('a') + 24) << endl; // прибавим к коду буквы 'a' число 25, получим код буквы 'y', сделаем символом
cout << char('a' + 24) << endl; // упрощенный способ записи
```

В Python:
```python
print(chr(ord('a') + 24)) # y
```

Так как сначала в таблице в алфавитном порядке записаны заглавные буквы, а затем строчные, то, чтобы узнать порядковый номер заглавной буквы, например 'N', нужно вычесть из ее кода код заглавной буквы 'A'.
```cpp
cout << 'N' - 'A' << endl; // 13
```

#### Цифры и символы

Иногда необходимо из символа получить числовое значение. Например:
> *Задано длинное число $n$, ($1 \le n \le 10^100$). Необходимо найти сумму всех его цифр.*

$10^100$ $mdash; это очень большое число, которое не поместится даже в тип данных long. Поэтому для решения этой задачи мы можем считать $n$ не как число, а как строку.

Последовательно переберем все символы данной строки, конвертируем их в цифры и сложим. Чтобы, например, из символа '8' получить число 8, нужно вспомнить, что в таблице ASCII цифры расположены в порядке возрастания. Символ '8' будет стоять на 8 позиций дальше, чем символ '0'.

Тогда, если у нас есть символ $c$, являющийся какой-то цифрой, то отняв из кода данного сивола код символа '0' ($c - '0'$), мы получим искомое числовое значение.

```cpp
    string s;
    cin >> s;
    int sum = 0;
    for(char c : s){
        sum += (c - '0');
    }
    cout << sum;
```
Обратное преобразование происходит аналогично: прибавим к символу '0' значение нужной цифры.

```cpp
    int x = 8;
    cout << char('0' + x); // получили символ '8'
```
#### Работа с регистрами

В с++ можно легко изменить регистр символа (сделать из строчного заглавным, либо наоборот). Для этого используются функции tolower и toupper.

```cpp
    char a = 'a', b = 'B';
    cout << char(toupper(a)) << ' ' << char(tolower(b)); // A b
```

Если необходимо изменить регистр всей строки, то можно перебрать все символы и изменить их по-отдельности.

В языке Python используются функции s.upper() и s.lower(), при помощи которых можно изменить регистр всей строки $s$.
#### Пример задачи

> *Задана строка, состоящая только из строчных латинских букв. Подсчитайте, сколько раз каждая из букв встречается в данной строке. Выведите ответ в формате "буква : количество", для каждой из букв на новой строке. Для букв, не встречающихся ни разу, строку выводить не нужно.*

* Заведем вектор, заполненный $26$ нулями. Ячейка c индексом $i$ будет содержать количество вхождений буквы, стоящей в алфавите под номером $i$, в нашу строку.
* Переберем все символы строки. Для каждой буквы узнаем ее порядковый номер в алфавите (от $0$ до $25$).
* В ячейку с найденным номером прибавим $1$.

```cpp
    string s;
    cin >> s;
    vector<int>letter(26, 0);
    for(char c : s){
        letter[c - 'a']++;
    }
    for(int i = 0; i < 26; i++) {
        if(letter[i] != 0) {
            cout << char('a' + i) << " : " << letter[i] << endl;
        }
    }
```

Например, для слова "abracadabra" вывод будет следующим:

~~~
a : 5
b : 2
c : 1
d : 1
r : 2
~~~

#### Символы и условия сравнения

Рассмотрим следующую задачу:

> *Задана строка. Посчитайте, какое количество ее символов является строчными латинскими буквами, а какое &mdash; цифрами. Выведите два числа &mdash; количество символов-строчных букв и количество символов-чисел соответственно.*

* Если символ является строчной латинской буквой, то его код находится между кодами букв 'a' и 'z'
* Если символ является цифрой, то его код находится между кодами цифр '0' и '9'

Тогда можем решить задачу следующим образом:

```cpp
    string s;
    cin >> s;
    int letter_cnt = 0, num_cnt = 0;
    for(char c : s){
        if(c >= 'a' && c <= 'z') letter_cnt++; //то же самое, что int(c) >= int('a') && int(c) <= int('z')
        else if(c >= '0' && c <= '9') num_cnt++;
    }
    cout << letter_cnt << ' ' << num_cnt;
```
### Перевод в другую систему счисления

Когда необходимо перевести число из одной системы счисления в другую, удобно использовать строки.

В явном виде можно реализовать алгоритм деления числа "столбиком" на основание системы счисления. (Этот алгоритм, кстати, также будет являться линейным. Будем рассматривать основания систем счисления, не превышающие 36.).

Приведем алгоритм перевода числа $n$ ($n \gt 0$) в двоичную систему счисления:

1. Создадим пустую строку $s$, в которую будем записывать результат.
2. Добавим в конец строки $s$ символ, равный $n \bmod 2$.
3. Разделим число $n$ нацело на $2$.
4. Если $n = 0$, то перевернем строку $s$ и получим ответ, иначе вернемся ко второму шагу.

Код на с++ будет выглядеть следующим образом:

```cpp
    int n;
    cin >> n;
    string s = "";
    while(n){ // аналогично условию "n > 0"
        s += char('0' + n % 2); // добавляем к строке символ, равный '0' либо '1'.
        n /= 2;
    }
    reverse(s.begin(), s.end()); // функция, переворачивающая строку
    cout << s;
```
Когда мы работаем, например, с шестнадцатеричной системой счисления, то для обозначения разрядов, значения которых больше $9$, используются заглавные латинские буквы:

~~~
A = 10
B = 11
C = 12
...
~~~

Модифицировать код для этого случая достаточно легко: изменим тело цикла следующим образом:

```cpp
    if(n % 16 < 10) s += char('0' + n % 16);
    else s += char('A' + (n % 16 - 10));
    n /= 16;
```