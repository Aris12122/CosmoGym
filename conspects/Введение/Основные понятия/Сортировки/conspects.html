<h1 id="-">Сортировки</h1>
<h2 id="-">Что такое сортировка?</h2>
<p>Задача <strong>сортировки</strong> массива заключается в том, чтобы расставить его элементы в определённом порядке (чаще всего - по неубыванию. Это означает, что каждый элемент должен быть больше или равен для всех предыдущих).</p>
<p>Например:</p>
<ul>
<li>массив $[1, 3, 3, 4, 12]$ отсортирован по неубыванию, </li>
<li>массив $[2, 4, 5, 13]$ отсортирован по возрастанию (и неубыванию),</li>
<li>массив $[10, 8, 5, -1]$ отсортирован по убыванию (и невозрастанию),</li>
<li>массив $[1, 13, 4, 5]$ не отсортирован.</li>
</ul>
<blockquote>
<p>Подумайте, какие массивы могут быть отсортированы и по возрастанию и по убыванию</p>
</blockquote>
<p><strong>Количество инверсий</strong> &mdash; это количество пар индексов $i$, $j$ таких, что $i &lt; j$ и $a[i] &gt; a[j]$ (если мы собираемся отсортировать массив по возрастанию). Такая пара индексов называется <strong>инверсией</strong>. Другое определение: минимальное необходимое количество свапов соседних элементов для того, чтобы отсортировать массив. </p>





<h2 id="-o-n-2-">Квадратичные сортировки ($O(n^2)$)</h2>
<h3 id="-">Сортировка пузырьком</h3>
<p>Наш подход будет заключаться в следующем: обозначим за $n$ длину массива и $n$ раз пройдёмся раз пройдемся по нему слева направо, меняя два соседних элемента, если первый больше второго.</p>
<p>Каждую итерацию максимальный элемент «всплывает» как пузырек к концу массива — отсюда и название.</p>
<p><a href="&#39;https://ru.algorithmica.org/cs/sorting/bubble/&#39;">Подробнее</a></p>
<p>Наглядный пример работы алгоритма сортировки пузырьком:</p>
<p><a href=""><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" border="1"></a></p>
<p>Примеры работы этого и последующих алгоритмов можно посмотреть по <a href="&#39;https://visualgo.net/en/sorting&#39;">ссылке</a></p>
<h3 id="-">Сортировка выбором</h3>
<p>Чтобы отсортировать массив, $n$ раз выберем минимум среди еще неотсортированных чисел и поставим его на свое место (а именно, на $k$ую позицию после $k$ой итерации). Чтобы упростить реализацию, на $k$ой итерации будем искать минимум на отрезке $[k, n - 1]$, меняя его местами с текущим $k$ым элементом, после чего отрезок $[0, k]$ будет отсортирован.</p>
<p><a href="&#39;https://ru.algorithmica.org/cs/sorting/selection/&#39;">Подробнее</a></p>
<h3 id="-">Сортировка вставками</h3>
<p>Пусть на $k$ом шаге у нас уже отсортирован префикс длины $k$. Чтобы увеличить этот отсортированный префикс, мы можем взять элемент, следующий после него, и менять его с левым соседом, пока этот элемент не окажется больше своего левого соседа. Когда это произойдет, это будет означать, что он будет больше всех элементов слева и меньше всех элементов префикса справа, и значит мы правильно вставили этот элемент в отсортированную часть массива.</p>
<p><a href="&#39;https://ru.algorithmica.org/cs/sorting/insertion/&#39;">Подробнее</a></p>





<h2 id="-">Сортировка подсчетом</h2>
<blockquote>
<p>Сортировка подсчетом предназначена для сортировки массива, состоящего из небольших чисел.</p>
</blockquote>
<p>Пусть, например, нам гарантируется, что все числа натуральные и лежат в промежутке от $1$ до $100$. Тогда есть такой простой алгоритм:</p>
<ul>
<li>Создадим массив размера $100$, в котором будем хранить на $k$ом месте, сколько раз число $k$ встретилось в этом массиве.</li>
<li>Пройдемся по всем числам исходного массива и увеличим соответствующее значение массива на $1$.</li>
<li>После того, как мы посчитали, сколько раз каждое число встретилось, можно просто пройтись по этому массиву и вывести $1$ столько раз, сколько встретилась $1$, вывести $2$ столько раз, сколько встретилась $2$, и так далее.</li>
</ul>
<p>Реализация:</p>
<pre><code class="lang-cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">count_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cnt(<span class="hljs-number">101</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        cnt[a[i]]++;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
        <span class="hljs-keyword">while</span> (cnt[i]-- &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">' '</span>;
        }
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</code></pre>
<p><a href="&#39;https://ru.algorithmica.org/cs/sorting/counting/&#39;">Подробнее</a></p>
<p><a href="&#39;https://algorithmica.org/tg/sorting&#39;">Подробнее про все сортировки</a></p>










<h2 id="-">Сортировка слиянием*</h2>
<blockquote>
<p>Идея алгоритма:</p>
<p>Допустим, нам надо отсортировать массив из $n$ чисел. Заметим, что если в нем только одно число($n=1$), то массив уже отсортирован. Иначе предположим, что массивы размеров меньше $n$ мы уже умеем сортировать. Тогда сделаем следующее: разделим массив на две примерно равные части (просто делим пополам), отдельно отсортируем левую, отдельно отсортируем правую часть. Нам останется только объединить эти два массива и получить результат.</p>
</blockquote>
<p>Пусть дан массив $a = [7,0,1,3,5,2,6,4]$. В таблице ниже показано, в каком порядке будут происходить деления и как потом ответ будет собираться из отсортированных кусочков.</p>
<table class="wikitable"><tbody>
<tr><th colspan="8" align="center">Разделяем
</th></tr>
<tr><td colspan="8" style="padding: 7px" align="center">7  0  1  3  5  2  6  4
</td></tr>
<tr>
<td colspan="4" style="padding: 7px" align="center">7 0 1 3</td>
<td colspan="4" align="center">5 2 6 4
</td>
</tr>
<tr>
<td colspan="2" style="padding: 7px" align="center">7 0</td>
<td colspan="2" align="center">1 3</td>
<td colspan="2" align="center">5 2</td>
<td colspan="2" align="center">6 4
</td>
</tr>
<tr>
<td style="padding: 7px">7</td>
<td>0</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>2</td>
<td>6</td>
<td>4
</td>
</tr>
<tr><th colspan="8" align="center">Сливаем
</th></tr>
<tr>
<td colspan="2" style="padding: 7px" align="center">0 7</td>
<td colspan="2" align="center">1 3</td>
<td colspan="2" align="center">2 5</td>
<td colspan="2" align="center">4 6
</td>
</tr>
<tr>
<td colspan="4" style="padding: 7px" align="center">0 1 3 7</td>
<td colspan="4" align="center">2 4 5 6
</td>
</tr>
<tr><td colspan="8" style="padding: 7px" align="center">0 1 2 3 4 5 6 7
</td></tr>
</tbody></table>

<blockquote>
<p>Функция $Merge$</p>
<p>Научимся сливать (объединять) два отсортированных массива. Для этого воспользуемся техникой двух указателей. Пусть указатель $p1$ стоит на некотором элементе первого массива, указатель $p2$ на элементе второго массива. Будем поддерживать условие, что сейчас в отсортированный массив надо добавить либо элемент $p1$, либо $p2$. Какой именно &mdash; можно узнать, сравнив между собой эти два элемента. Если $a[p1]≤b[p2]$, то надо сложить в ответ $a[p1]$ и сдвинуть $p1$ на единицу вправо. Иначе делаем то же самое, но уже с $p2$.</p>
<p>Количество смещений двух указателей не превосходит суммы длин двух массивов, поэтому такое слияние выполнится за $O(n+m)$, где $n$,$m$ - длины двух массивов.</p>
</blockquote>
<p>Время работы:</p>
<p>Вспомним наш пример. Заметим, что каждый уровень состоит из одинакового количества элементов, на каждом уровне происходит серия операций merge, но суммарно на каждом уровне все они выполнятся за $O(n)$, так как время на $merge$ линейно зависит от количества чисел в массивах. Теперь оценим количество уровней. На каждом размер сортируемого блока уменьшается в два раза, быть меньше единицы этот блок не может(иногда они вырождаются в пустые блоки, если длины массива &mdash; не степень двойки), поэтому уровней будет столько, сколько раз $n$ можно поделить на $2$. Это $logn$. Тогда весь алгоритм работает за $O(nlogn)$.</p>
<p><a href="&#39;https://wiki.algocode.ru/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC&#39;">Подробнее про сортировку слиянием</a></p>
<p><a href="&#39;https://algorithmica.org/tg/sorting&#39;">Подробнее про все сортировки</a></p>










<h2 id="-">Встроенные сортировки</h2>
<pre><code class="lang-python"><span class="hljs-keyword">a</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]
<span class="hljs-keyword">a</span>.<span class="hljs-built_in">sort</span>()
print(<span class="hljs-keyword">a</span>)
<span class="hljs-comment"># Вывод: [1, 2, 3]</span>
</code></pre>
<pre><code class="lang-cpp">int a[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
<span class="hljs-type">vector</span>&lt;int&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
sort(a, a + <span class="hljs-number">3</span>);
sort(v.begin(), v.end());
<span class="hljs-comment">// или же:</span>
sort(v.begin(), v.begin() + <span class="hljs-number">3</span>);
</code></pre>
<p>Встроенная сортировки чаще всего использую алгоритм быстрой сортировки ($quick$ $sort$). Его мы разберем позже. Асимптотика у этого алгоритма такая же, как и у сортировки слиянием но на практике он работает быстрее.</p>
<blockquote>
<p>В соответствующем контесте <strong>запрещено</strong> пользоваться встроенными сортировками для решения задач, напишите свою сортировку для понимания алгоритма. </p>
<p>Также постарайтесь меньше обращаться к примерам реализации, а сначала пытайтесь реализовывать все самостоятельно.</p>
<p>Это поможет вам реализовывать алгоритмы &quot;на слух&quot;. То есть по теории и идеи алгоритма писать его самостоятельно.</p>
</blockquote>







