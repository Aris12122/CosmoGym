# Сортировки

## Что такое сортировка?

Задача **сортировки** массива заключается в том, чтобы расставить его элементы в определённом порядке (чаще всего - по неубыванию. Это означает, что каждый элемент должен быть больше или равен для всех предыдущих).

Например:
* массив $[1, 3, 3, 4, 12]$ отсортирован по неубыванию, 
* массив $[2, 4, 5, 13]$ отсортирован по возрастанию (и неубыванию),
* массив $[10, 8, 5, -1]$ отсортирован по убыванию (и невозрастанию),
* массив $[1, 13, 4, 5]$ не отсортирован.

> Подумайте, какие массивы могут быть отсортированы и по возрастанию и по убыванию

**Количество инверсий** &mdash; это количество пар индексов $i$, $j$ таких, что $i < j$ и $a[i] > a[j]$. Такая пара индексов называется **инверсией**.

***

## Квадратичные сортировки ($O(n^2)$)


### Сортировка пузырьком

Наш подход будет заключаться в следующем: обозначим за $n$ длину массива и $n$ раз пройдёмся раз пройдемся по нему слева направо, меняя два соседних элемента, если первый больше второго.

Каждую итерацию максимальный элемент «всплывает» как пузырек к концу массива — отсюда и название.

[Подробнее]('https://ru.algorithmica.org/cs/sorting/bubble/')

Наглядный пример работы алгоритма сортировки пузырьком:

<a href=""><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" border="1"></a>

Примеры работы этого и последующих алгоритмов можно посмотреть по [ссылке]('https://visualgo.net/en/sorting')


### Сортировка выбором

Чтобы отсортировать массив, $n$ раз выберем минимум среди еще неотсортированных чисел и поставим его на свое место (а именно, на $k$ую позицию после $k$ой итерации). Чтобы упростить реализацию, на $k$ой итерации будем искать минимум на отрезке $[k, n - 1]$, меняя его местами с текущим $k$ым элементом, после чего отрезок $[0, k]$ будет отсортирован.


[Подробнее]('https://ru.algorithmica.org/cs/sorting/selection/')

### Сортировка вставками

Пусть на $k$ом шаге у нас уже отсортирован префикс длины $k$. Чтобы увеличить этот отсортированный префикс, мы можем взять элемент, следующий после него, и менять его с левым соседом, пока этот элемент не окажется больше своего левого соседа. Когда это произойдет, это будет означать, что он будет больше всех элементов слева и меньше всех элементов префикса справа, и значит мы правильно вставили этот элемент в отсортированную часть массива.

[Подробнее]('https://ru.algorithmica.org/cs/sorting/insertion/')


***

## Сортировка подсчетом

> Сортировка подсчетом предназначена для сортировки массива, состоящего из небольших чисел.

Пусть, например, нам гарантируется, что все числа натуральные и лежат в промежутке от $1$ до $100$. Тогда есть такой простой алгоритм:

* Создадим массив размера $100$, в котором будем хранить на $k$ом месте, сколько раз число $k$ встретилось в этом массиве.
* Пройдемся по всем числам исходного массива и увеличим соответствующее значение массива на $1$.
* После того, как мы посчитали, сколько раз каждое число встретилось, можно просто пройтись по этому массиву и вывести $1$ столько раз, сколько встретилась $1$, вывести $2$ столько раз, сколько встретилась $2$, и так далее.

Реализация:
```cpp
void count_sort(int *a, int n) {
    vector<int> cnt(101, 0);
    for (int i = 0; i < n; i++) {
        cnt[a[i]]++;
    }
    for (int i = 0; i <= 100; i++) {
        while (cnt[i]-- > 0) {
            cout << i << ' ';
        }
    }
    cout << endl;
}
```


[Подробнее]('https://ru.algorithmica.org/cs/sorting/counting/')

[Подробнее про все сортировки]('https://algorithmica.org/tg/sorting')

***

## Сортировка слиянием*

> Идея алгоритма:
> 
> Допустим, нам надо отсортировать массив из $n$ чисел. Заметим, что если в нем только одно число($n=1$), то массив уже отсортирован. Иначе предположим, что массивы размеров меньше $n$ мы уже умеем сортировать. Тогда сделаем следующее: разделим массив на две примерно равные части (просто делим пополам), отдельно отсортируем левую, отдельно отсортируем правую часть. Нам останется только объединить эти два массива и получить результат.


Пусть дан массив $a = [7,0,1,3,5,2,6,4]$. В таблице ниже показано, в каком порядке будут происходить деления и как потом ответ будет собираться из отсортированных кусочков.


<table class="wikitable"><tbody>
<tr><th colspan="8" align="center">Разделяем
</th></tr>
<tr><td colspan="8" style="padding: 7px" align="center">7  0  1  3  5  2  6  4
</td></tr>
<tr>
<td colspan="4" style="padding: 7px" align="center">7 0 1 3</td>
<td colspan="4" align="center">5 2 6 4
</td>
</tr>
<tr>
<td colspan="2" style="padding: 7px" align="center">7 0</td>
<td colspan="2" align="center">1 3</td>
<td colspan="2" align="center">5 2</td>
<td colspan="2" align="center">6 4
</td>
</tr>
<tr>
<td style="padding: 7px">7</td>
<td>0</td>
<td>1</td>
<td>3</td>
<td>5</td>
<td>2</td>
<td>6</td>
<td>4
</td>
</tr>
<tr><th colspan="8" align="center">Сливаем
</th></tr>
<tr>
<td colspan="2" style="padding: 7px" align="center">0 7</td>
<td colspan="2" align="center">1 3</td>
<td colspan="2" align="center">2 5</td>
<td colspan="2" align="center">4 6
</td>
</tr>
<tr>
<td colspan="4" style="padding: 7px" align="center">0 1 3 7</td>
<td colspan="4" align="center">2 4 5 6
</td>
</tr>
<tr><td colspan="8" style="padding: 7px" align="center">0 1 2 3 4 5 6 7
</td></tr>
</tbody></table>

> Функция $Merge$
> 
> Научимся сливать (объединять) два отсортированных массива. Для этого воспользуемся техникой двух указателей. Пусть указатель $p1$ стоит на некотором элементе первого массива, указатель $p2$ на элементе второго массива. Будем поддерживать условие, что сейчас в отсортированный массив надо добавить либо элемент $p1$, либо $p2$. Какой именно &mdash; можно узнать, сравнив между собой эти два элемента. Если $a[p1]≤b[p2]$, то надо сложить в ответ $a[p1]$ и сдвинуть $p1$ на единицу вправо. Иначе делаем то же самое, но уже с $p2$.
> 
> Количество смещений двух указателей не превосходит суммы длин двух массивов, поэтому такое слияние выполнится за $O(n+m)$, где $n$,$m$ - длины двух массивов.


Время работы:

Вспомним наш пример. Заметим, что каждый уровень состоит из одинакового количества элементов, на каждом уровне происходит серия операций merge, но суммарно на каждом уровне все они выполнятся за $O(n)$, так как время на $merge$ линейно зависит от количества чисел в массивах. Теперь оценим количество уровней. На каждом размер сортируемого блока уменьшается в два раза, быть меньше единицы этот блок не может(иногда они вырождаются в пустые блоки, если длины массива &mdash; не степень двойки), поэтому уровней будет столько, сколько раз $n$ можно поделить на $2$. Это $logn$. Тогда весь алгоритм работает за $O(nlogn)$.


[Подробнее про сортировку слиянием]('https://wiki.algocode.ru/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC')

[Подробнее про все сортировки]('https://algorithmica.org/tg/sorting')

***

## Встроенные сортировки

```python
a = [3, 2, 1]
a.sort()
print(a)
# Вывод: [1, 2, 3]
```

```cpp
int a[3] = {1, 2, 3};
vector<int> v = {1, 2, 3};
sort(a, a + 3);
sort(v.begin(), v.end());
// или же:
sort(v.begin(), v.begin() + 3);
```

Встроенная сортировки чаще всего использую алгоритм быстрой сортировки ($quick$ $sort$). Его мы разберем позже. Асимптотика у этого алгоритма такая же, как и у сортировки слиянием но на практике он работает быстрее.

> В соответствующем контесте **запрещено** пользоваться встроенными сортировками для решения задач, напишите свою сортировку для понимания алгоритма. 
> 
> Также постарайтесь меньше обращаться к примерам реализации, а сначала пытайтесь реализовывать все самостоятельно.
> 
> Это поможет вам реализовывать алгоритмы "на слух". То есть по теории и идеи алгоритма писать его самостоятельно.