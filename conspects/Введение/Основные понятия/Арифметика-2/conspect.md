## Арифметика - 2

### Быстрое возведение в степень

Ранее мы могли использовать следующую функцию для возведения числа в степень:

```cpp
int power(int a, int n){
    int ans = 1;
    for(int i = 0; i < n; i++){
        ans *= a;
    }
    return ans;
}
```

Для того, чтобы возвести число в степень $n$ нам необходимо было в точности $n$ операций, соответсвенно, асимптотика данного решения составляла $O(n)$.

Однако, существует способ, позволяющий возводить число в степень гораздо быстрее. Он базируется на следующих свойствах степеней (где $a, n \in \R$) ! (или неопределенности исключаем??)

1. $a^{2n} = (a^n)^2$ 
2. $a^{2n + 1} = (a^n)^2 \cdot a$

Проиллюстрировать это более наглядно можно так:

Пусть мы хотим возвести число $2$ в $10$ степень. Тогда рассмотрим цепочку преобразований:

> $2^{10} = 2^{2 \cdot 5} = (2^5)^2 = (2^{4 + 1})^2 = (2^4 \cdot 2)^2 = ((2^2)^2 \cdot 2)^2$

Итого, $2^{10} = ((2^2)^2 \cdot 2)^2$ и искомое начение вычислятся за $4$ шага

1. $2^2 = 4$
2. $4^2 = 16$
3. $16 \cdot 2 = 32$
4. $32^2 = 1024$

Вместо $10$ операций в цикле мы совершили $4$. Для маленьких значений $n$ данная разница незначительна, но при больших такой подход сильно оптимизирует время работы программы.

### Рекурсивная рализация

Для начала напишем рекурсивную реализацию &mdash; функцию $binpow(a, n)$. Для этого используем рекуррентные формулы из прошлого шага:

* если $n$ будет четно, будем возвращать $binpow(a, n / 2) \cdot binpow(a, n / 2)$
* если $n$ будет нечетно, будем возвращать $binpow(a, n - 1) \cdot a$

Также необходимо иметь базу рекурсии: 
* если $n = 0$, то вне зависимости от $a$ будем возвращать $1$, так как $a^0 = 1$ для любого* значения $a$.

Получим код на Python

```py
def binpow(a, n):
    if n == 0:
        return 1
    elif n % 2 == 0:
        return binpow(a, n // 2) ** 2
    else:
        return binpow(a, n - 1) * a

print(binpow(2, 10))
```
Асимптотика такого решения &mdash; $O(log(n))$, так как мы совершим действий столько, сколько раз можно разделить значение $n$ на $2$.

### Нерекурсивная реализация

Теперь попробуем реализовать этот алгоритм итеративно.

В цикле while будем уменьшать значение $n$ в два раза, если $n$ четно, или уменьшать его на единицу в противном случае.

```py
def binpow(n, a):
    res = 1
    while n:
        if n % 2 == 0:
            a *= a
            n //= 2
        else:
            res *= a
            n -= 1
    return res
```

### Операции по модулю

Часто в задачах вы будете встречаться с формулировкой, похожей на следующую:

> *Так как ответ может получиться достаточно большим, выведите его по модулю $10^9 + 7$.*

Она особенно характерна для комбинаторных задач, где величины растут очень быстро.

В прошлом разделе мы рассмотрели определение остатка от деления. "Вывести ответ по модулю $m$" означает, что необходимо вывести остаток от деления полученного ответа на число $m$.

Посмотрим подробнее на примере задачи:

> Выведите $n$-е ($1 \le n \le 10^4$) число Фибоначчи по модулю $10^6 + 3$.

Первая мысль, которая может возникнуть &mdash; посчитать ответ как обычно и в конце один раз взять ответ по модулю, вот так:

```cpp
    int f0 = 1; //значение позапрошлого числа Фибоначчи
    int f1 = 1; //значение прошлого числа Фибоначчи
    int f = 1;  //значение текущего числа Фибоначчи
    int mod = 1e6 + 3;
    for(int i = 2; i <= n; i++){
        f = f0 + f1;
        cout << f <<", ";
        f0 = f1;
        f1 = f;
    }   
    cout << endl << (f % mod);
```
Однако помотрим на последовательность значений $f$, которые будут выведены на экран:

> 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 1213
93, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986,
 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, -1323752223 ...

 Откуда взялось отрицательное число $-1323752223$? Дело в том, что произошло переполнение: мы сложили два числа $1836311903 + 1134903170 = 2971215073$. 
 
 Однако, макимальное число, которое вмещается в тип int это $2^{31} - 1 = 2147483647$. Попытавшись записать в int число большее, чем это возможно, мы получили некорректный результат. (Подробнее о том, почему переполнение работает именно так, можно прочитать [здесь]().(Добавить ссылку!)

 Так как все последующие числа Фибоначчи зависят от предыдущих, то все числа далее будут подсчитаны неправильно, и в конце мы посчитаем остаток от деления совсем не от того числа, которое хотели бы получить. 

 ### Сложение по модулю

 Таким образом, один раз брать ответ по модулю недостаточно, необходимо изменять уже промежуточные значения.

Преобразуем вычисление $f$:
```
f = (f0 + f1) % mod
```
Мы можем так сделать, пользуясь следующей теоремой. 

> $(a+b) \bmod m=((a \bmod m)+(b \bmod m)) \bmod m$

С ее доказательством можно познакомится [здесь](https://brestprog.by/topics/modulo/).

В нашем случае, мы хотим вычислить $f_n \bmod m = (f_{n-1} + f_{n-2}) \bmod n = ((f_{n-2} + f_{n-3}) + (f_{n-3} + f_{n-4})) \bmod n = \dots$, а потому, пользуясь теоремой, берем по модулю каждое из слагаемых.

### Умножение по модулю:

Рассмотрим следующую задачу:

> Вычислите значение $n!$ ($1 \le n \le 10^6$) по модулю $10^9 + 7$

Здесь нам понадобится воспользоваться теоремой, аналогичной предыдущей:

> $(a \cdot b) \bmod m=((a \bmod m) \cdot (b \bmod m)) \bmod m$

```cpp
int f = 1;
int mod = 1e9 + 7; //10^n можно записать как 1en, где n - целое число
for(int i = 1; i <= n; i++){
    f = (f * i) % mod;
}
cout << f;

```
Ничего не меняется, также на каждом шаге вычисления берем его результат по модулю. 

### Операции по модулю для отрицательных чисел

Остаток от деления отрицательного числа в с++ и python берется некорректно. 
Можно убедиться в этом: запустите следующий код на с++, а затем на python:

```cpp
cout << (-28) % 3;
```
```py
print((-28) % 3)
```
Запишем число $-28$ следующим образом:

> $-28 = 3 \cdot q + r$

 где $r$ &mdash; остаток от деления на $3$, $q$ &mdash; целая часть от деления.

Неверно было бы сказать, что $-28 = 3 \cdot (-9) + (-1)$, потому что по определению остаток всегда неотрицателен! (так, остатки от деления на $3$ &mdash; это $0, 1, 2$. )

Поэтому верно было бы записать, что $-28 = 3 \cdot (-10) + 2$

Для того, чтобы вычислять остаток от деления отрицательного числа $n$ правильно, воспользуемся формулой:

> $n \bmod m = ((n \bmod m) + m) \bmod m$


О доказательстве этой формулы можно прочитать [здесь](). (Добавить ссылку!)

### Деление по модулю

В отличие от умножения и сложения, деление реализовавыется иначе. Нам известно, что $\frac{a}{b} = a \cdot \frac{1}{b} = a \cdot b^{-1}$, однако необходимо понять, что такое $b^{-1}$, когда мы работаем с модульной арифметикой.


