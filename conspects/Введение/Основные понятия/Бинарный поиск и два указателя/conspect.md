# Бинарный поиск и метод двух указателей

## Бинарный поиск

Основная идея заключается в следующем: у нас есть такая функция, что все её элементы до $k$го принимают значения $False$, а начиная с $k$го $True$. Тогда мы можем быстро найти значение $k$.

Допустим у нас есть монотонная (сначала идут нули, затем единицы) бинарная строка $s = 000000011111$ размера $n = 12$ и нам необходимо узнать, сколько в ней нулей.

В данном примере пусть индексация в строке начинается с $1$. Тогда скажем, что $s[0] = 0$ всегда, а $s[13] = 1$. Про остальные элементы мы пока ничего не знаем.

Заведем границы поиска $left$ и $right$. Будем придерживаться инварианта, что $s[left] = 0$, $s[right] = 1$. Мы будем сближать $left$ и $right$, пока они не станут соседними. Тогда мы точно сможем сказать, что элементы с индексами $s[1] = s[2] = \dots = s[left] = 0$. А все остальные элементы: $s[right] = s[right+1] = \dots = s[n] = 1$.

Вся идея алгоритма кроется в следующем: выберем число $mid$ между $left$ и $right$ такое, что оно находится примерно посередине. Тогда возможны два варианта:

1) $s[mid] = 0$, тогда: $s[left] = s[left + 1] = \dots = s[mid] = 0$ и мы можем присвоить $left = mid$
2) $s[mid] = 1$, тогда: $s[mid] = s[mid+1] = \dots = s[right] = 1$ и мы можем присвоить $right = mid$

> В обоих случаях мы сократим наши поиски вдвое, так как расстояние между $left$ и $right$ сократится вдвое. Таким образом, асимптотика данного алгоритма составляет $O(logn)$

Реализация:
```cpp
int n;
string s;
cin >> s;
n = s.length();
int left = -1, right = n; // В данном случае будем пользоваться индексацией с нуля

while (right - left > 1) {
    int mid = (left + right) / 2;
    if (s[mid] == '1') {
        right = mid;
    } else {
        left = mid;
    }
}
printf("String s contains %d zeros\n", left); 
```

> Рассмотрим теперь другую задачу: загадано число $x$ ($1 \le x \le 10^9$). Вы можете спросить: "? k" в качестве ответа вам выведут $True$, если число $k \le x$ и $False$ иначе. Вам необходимо узнать число $x$ за не более чем $50$ запросов.

Для решения этой задачи воспользуемся той же идеей. Будем поддерживать инвариант: $left \le x$, $right > x$. Тогда при нахождении очередного $mid$ возможны два случая:

1) На запрос "? mid" нам пришел ответ $True$, тогда можем присвоить $left = mid$
2) Иначе ответ $False$ и $mid > x$. Следовательно, можем присвоить $right = mid$


Подробнее: [algorithmica](https://ru.algorithmica.org/cs/interactive/binary-search/), [algocode](https://wiki.algocode.ru/index.php?title=%D0%91%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA)

***

## Вещественный бинпоиск

Проблема работы с вещественными числами состоит в том, что они **хранятся неточно**. Про хранение чисел мы поговорим позже.

Например:
```py
print(0.1 + 0.1 + 0.1)
# вывод: 0.30000000000000004
```

Решим такую задачу: необходим найти корень числа $x$. Из-за проблемы описанной выше, в таких задачах необходимо вывести ответ с какой-то точностью, к примеру давайте выведем ответ с точностью до $10^{-6}$.

Давайте оценим, сколько итераций нам необходимо провести, чтобы получить такую точность? Это зависит от ограничений на $x$. Допустим $1 \le x < 10^9$. Тогда нам фактически нужно получить число, состоящее максимум из $9 + 6 = 15$ цифр. То есть как будто мы ищем ответ в целых числах, но в ограничениях $ < 10^{15}$. Тогда нам понадобится примерно $log(10^{15}) = 10 * 3 = 30$ шагов. 

> Конечно мы не хотим в каждой задаче считать, сколько нам нужно сделать шагов чтобы получить достаточно точный ответ, поэтому часто ставят $100$ шагов и не думают об этом.

Реализация:

```py
x = int(input())
l = 0, r = x
for i in range 100:
    m = (l + r) / 2
    if m * m <= x:
        l = m
    else:
        r = m
print(l)
```
[Подробнее]('https://wiki.algocode.ru/index.php?title=%D0%91%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA_%D1%81_%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8_%D1%87%D0%B8%D1%81%D0%BB%D0%B0%D0%BC%D0%B8')

*** 

## Бинпоиск по ответу


&mdash; это разновидность бинпоиска, когда мы не знаем ответ, но можем сказать, что существует некая монотонность.

> Задача: На прямой расположены $n$ стойл (даны их координаты $a_i$ на прямой), в которые необходимо расставить $k$ коров так, чтобы минимальное расстояние между коровами было как можно больше. 
> Гарантируется, что ($1 < k < n$) и ($1 \le a_i \le 10^9$).

Давайте думать так: допустим мы знаем, что минимальное расстояние между коровами $x$. Тогда сможем ли мы расставить $k$ коров по стойлам? Мы можем проверить это, воспользовавшись "жадным" решением:

Поставим первую корову в первое стойло, вторую корову в ближайшее стойло, которое находится на расстоянии не меньше $x$ и так далее, пока не поставим $k$ коров или узнаем, что это невозможно.

Заметим, что при $x = 0$ мы всегда можем расставить $k$ коров, тогда как при $x = 10^9$ не сможем расставить больше одной, а $k > 1$. Соответственно можем поставить границы бинпоиска $l = 0, r = 10^9$.

> Важно отметить монотонность: если для $x = y$ мы можем расставить $k$ коров, то и для $x = y-1$ мы можем их расставить.
> Аналогично, если для $x = y$ мы не можем расставить $k$ коров, то и для $x = y+1$ мы не сможем их расставить.
>
> Следовательно существует наибольшее значение $x = ans$, для которого мы можем расставить $k$ коров, как и для всех меньших значений. А при $x = ans + 1$ уже не можем. Тогда и для всех больших значений мы не можем этого сделать.


```cpp

int n, k;
vector<int> a;
bool check(int x) {
    int cnt = 1;
    int pr = 0;
    for (int i = 1; i < n; i++) {
        if (a[i] - a[pr] >= x) {
            cnt++;
            pr = i;
        }
    }
    return cnt >= k;
    // O(n)
}

int solve() {
    cin >> n >> k;
    a.resize(n);
    sort(a.begin(), a.end());
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    int l = 0, r = 1e9;
    while (r - l > 1) {
        int m = (l + r) / 2;
        if (check(m)) {
            l = m;
        } else {
            r = m;
        }
    }
    cout << l << endl;
    // O(nlogA)
}
```

[Подробнее]('https://ru.algorithmica.org/cs/interactive/answer-search/')


*** 

## Два указателя

Мы уже применяли два указателя в [сортировке слиянием](''). 

Там нам было дано два отсортированных массива $a$ и $b$. Из них мы составляли новый отсортированный массив $c$, состоящий из элементов массивов $a$ и $b$. При этом мы хранили два указателя на минимальный из еще не добавленных элементов в массиве $a$ и $b$ соответственно. Выбирали из них наименьший элемент и добавляли в $c$, при этом сдвигая указатель.

>Задача:
>
> Дан отсортированный массив $a$ размера $n$ и целое число $K$. Найдите количество пар индексов $i, j$ таких, что $a[j] - a[i] > K$.

1. Первое решение:
    
    Воспользуемся бинпоиском: будем перебирать индекс $i$ от $0$ до $n-1$ и находить для каждого такого $i$ первый индекс $j \ge i$ такой, что $a[j] - a[i] > K$. Нетрудно заметить, что все индексы большие $j$ также подходят. Таким образом, можем решить эту задачу за $O(nlogn)$.
2. Второе решение:
    Будем также перебирать первый указатель $i$ от $0$ до $n-1$. Заметим, что искомое значение $j$ из первого решения для следующего $i$ либо увеличится, либо останется прежним. Так как мы увеличили значение $a[i]$, соответственно должны найти $a[j] > K + a[i]$ больше чем предыдущее.

Реализация второго решения:

```cpp
for (int i = 0, j = 0; i < n; i++) {
    if (j < i) j = i;
    while (j < n && a[j] - a[i] <= K) j++;
    ans += n - j; //кол-во подходящих индексов
}
```

> Асимптотика у такого решения будет равна $O(n)$, потому что суммарно $j$ принимает не более чем $n$ значений и $i$ также суммарно примет не более $n$ значений.

[Подробнее]('https://algorithmica.org/tg/mergesort')

***
