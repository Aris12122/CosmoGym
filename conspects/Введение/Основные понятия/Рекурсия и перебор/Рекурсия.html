<h2 id="рекурсия">Рекурсия</h2>
<h3 id="как-работает-рекурсивная-функция">Как работает рекурсивная функция?</h3>
<p>Для начала познакомимся с таким понятием, как <strong>рекуррентная формула</strong>.</p>
<blockquote>
    <p><strong>Рекуррентная формула</strong> &mdash; формула, в которой каждое последующее значение зависит от предыдущего (или нескольких предыдущих). </p>
</blockquote>
<p>Например, уже знакомые нам <em>числа Фибоначчи</em> задаются следующей формулой:</p>
<p>$F_n = F_{n - 1} + F_{n - 2}$</p>
<p>Рекуррентной формулой задается и <em>факториал</em> числа $n$:</p>
<p>$n! = (n - 1)! * n$</p>
<p>Формально, <strong>рекурсивная функция</strong> реализует вычисление значения по рекуррентной формуле или реализует последовательность действий, рекуррентно зависящих друг от друга.</p>
<p>Чаще можно встретиться со следующим определением: </p>
<blockquote>
    <p><strong>Pекурсивная функция</strong> &mdash; это такая функция, которая вызывает саму себя.</p>
</blockquote>
<h3 id="бесконечная-рекурсия">Бесконечная рекурсия</h3>
<p>Вы уже знакомы с бесконечным циклом. Например, следующий код будет бесконечно* выводить число $1$.</p>
<pre><code class="language-py">while True:
    print(1)
</code></pre>
<p>Аналогично можно представить себе рекурcивную функцию, которая бесконечно вызывает саму себя:</p>
<pre><code class="language-py">def F(x):
    return F(x)
</code></pre>
<p>Как избежать такого? Всегда необходимо иметь условие выхода из рекурсии. Например, если мы посмотрим на следующий код, вычисляющий факториал числа $n$.</p>
<pre><code class="language-py">def Fact(n):
    if n &lt;= 1:
        return 1
    else:
        return n * Fact(n - 1)
</code></pre>
<p>Рассмотрим, что произойдет, если мы вызовем $F(3)$.</p>
<ul>
    <li>$3 \gt 1$, возвращаем $3 \cdot Fact(3 - 1)$.</li>
    <li>$Fact(3 - 1)$ &mdash; это $F(2)$. При этом $2 \gt 1$, возвращаем $2 \cdot Fact(2 - 1)$.</li>
    <li>$Fact(2 - 1)$ &mdash; это $Fact(1)$. При этом $1 \le 1$. Тогда мы не вызываем нашу функцию $Fact$ еще раз, а просто возвращаем число $1$.</li>
</ul>
<p>C этого момента мы не будем больше вызывать фунцию $Fact$ и начнется этап рефлексии (вставить картинку)</p>
<h3 id="пример-дерево-рекурсии-и-вычисление-чисел-фибоначчи">Пример: дерево рекурсии и вычисление чисел Фибоначчи</h3>
<p>Научимся вычислять $n$-е число Фибоначчи. Для начала еще раз вспомним формулу:</p>
<blockquote>
    <p>$F_0$ = 1</p>
    <p>$F_1$ = 1</p>
    <p>$F_n = F_{n - 1} + F_{n - 2}$</p>
</blockquote>
<p>Функцию, которая будет выполнять вычисление числа Фибонначчи, назовем $F(x)$. Сразу заметим, что значение первых двух чисел Фибоначчи нам известны, они являются константами.</p>
<p>Версия для Python</p>
<pre><code class="language-py">def F(x):
    if x &lt;= 0:
        return 1
    if x == 1:
        return 1
    return F(x - 1) + F(x - 2)

print(F(4))
</code></pre>
<p>Версия для С++</p>
<pre><code class="language-cpp">int F(int x){
    if(x &lt;= 0) return 1;
    if(x == 1) return 1;
    return F(x - 1) + F(x - 2);
}

int main(){
    cout &lt;&lt; F(4);
}
</code></pre>
<p>Для большего удобства сопоставляйте пункты, написанные ниже, с картинкой.</p>
<p><a href="https://imgbb.com/"><img src="https://i.ibb.co/VQhqbXF/graph-3.png" alt="graph-3" border="0"></a></p>
<ul>
    <li>Мы хотим посчитать $F(4)$. Для этого нужно посчитать $F(3) + F(2)$. Так как $F(3)$ стоит в нашей сумме первым, то посчитаем сначала его.</li>
    <li>Вызвав $F(3)$, понимаем, что нужно посчитать $F(2) + F(1)$. Первое слагаемое &mdash; $F(2)$ &mdash; посчитаем его.</li>
    <li>Вызываем $F(2)$. Теперь нужно посчитать $F(1) + F(0)$.</li>
    <li>Вызываем $F(1)$. Оно не зависит от предыдущих значений и всегда равно $1$. Мы спустились до самого низа и теперь начинаем подниматься. Зачем мы считали $F(1)$? Потому что оно было слагаемым суммы $F(1) + F(0)$. Значит, теперь мы считаем $F(0)$.</li>
    <li>$F(0)$ также всегда возвращает $1$. И мы снова поднимаемся на шаг назад. $F(2) = F(1) + F(0) = 1 + 1 = 2$. Мы посчитали значение для $F(2)$. А оно было нужно, чтобы посчитать $F(3) = F(2) + F(1)$. Первое слагаемое известно &mdash; считаем второе &mdash; вызываем $F(1)$.</li>
</ul>
<p>Дальнейший алгоритм будет аналогичен &mdash; спускаемся по &quot;ветке&quot;, пока не достигаем такого значения, которое не зависит от предыдущего &mdash; тогда возвращаемся на шаг назад к предыдущему разветвлению.</p>
<h3 id="оптимизация-рекурсии-мемоизация">Оптимизация рекурсии: мемоизация</h3>
<p>Для $n=6$ дерево стало уже очень большим. При этом, многие значения нам приходится считать по несколько раз!</p>
<p><a href="https://ibb.co/zFNrhtn"><img src="https://i.ibb.co/gd63Mcj/graph-6.png" alt="graph-6" border="0"></a></p>
<p>Прием, позволяющий уменьшить количество вызовов, называется мемоизация (без Р). Заведем массив $count$ на $n$ элементов, в котором $count[0] = count[1] = 1$. Если мы уже посчитали $F(n)$, то заполним $count[n] = F(n)$. Каждый раз при входе в функцию будем проверять, заполнено ли уже $count[n]$, и если да, то просто будем возвращать его значение:</p>
<pre><code class="language-py">def F(x):
    if count[x]:
        return count[x]
    return F(x - 1) + F(x - 2)

print(F(6))
</code></pre>
<h3 id="рекурсивные-переборы">Рекурсивные переборы**</h3>
<p>Пусть перед нами стоит такая задача: </p>
<blockquote>
    <p><strong>Выведите все строки длины  $10$, состоящие из букв $a, b, c$</strong>.</p>
</blockquote>
<p>Конечно, мы можем написать $10$ вложенных циклов, но такое решение займет много времени и места в коде, в нем легко ошибиться. Тем более, смысл каждого цикла одинаков &mdash; выбираем индекс элемента в строке.</p>
<p>Тогда давайте напишем рекурсивную функцию, которая просто $10$ раз вызывает такой вложенный цикл! </p>
<ul>
    <li><p>Будем передавать в функцию строку, которая у нас есть на текущий момент.</p>
    </li>
    <li><p>Когда рекурсия должна остановиться? Когда длина строки равна $10$. Сразу пропишем условие: </p>
        <pre><code class="language-py">if len(s) == 10:
    a.add(s) #положили в set
    return #вышли из функции
</code></pre>
    </li>
    <li><p>В теле функции напишем цикл $for$, в котором переберем индекс буквы из строки $base$ и будем вызывать $F(s + base[i])$</p>
    </li>
    <li><p>Вызовем нашу функцию от пустой строки, потому что первая из букв может быть любой из возможных трех.</p>
    </li>
</ul>
<p>Написав $return$, мы говорим, что не будем дальше спускаться по этой ветке &mdash; сразу поднимемся наверх и посмотрим, какой вариант последней буквы для нашей строки выберем следующим.</p>
<ul>
    <li>Соберем весь код
        ```py
        base = &#39;abc&#39;
        a = set()</li>
</ul>
<p>def F(s):
    if len(s) == 4:
    a.add(s)
    return
    for i in range(3):
    F(s + base[i])</p>
<p>F(&#39;&#39;)
    for i in a:
    print(i)</p>
<pre><code>
По аналогии можете попробовать решить самостоятельно любую из следующих [задач ЕГЭ](https://inf-ege.sdamgia.ru/test?theme=378) :)

### Минусы рекурсии

Это мощный инструмент, который важно понять и не бояться его использовать, но помнить, что чаще всего он не оптимален. Большинство рекурсивных решений можно заменить нерекурсивными. Например &amp;mdash; вычисление НОД ( [здесь](https://e-maxx.ru/algo/euclid_algorithm) можно сравнить рекурсивную версию алгоритма с нерекурсивной).

* При вызове рекурсивной функции стек заполняется данными о ее предыдущих шагах, в следствие чего программа задействует много памяти, и вы можете получить вердикт &lt;span style=&quot;color:red&quot;&gt;memory limit exceeded&lt;/span&gt;.

&gt; **Что такое стек?**
&gt;
&gt; Представьте, что вы складываете стопку книг на стол. Книга, положенная самой первой, окажется внизу, а самой последней &amp;mdash; вверху. Теперь вы хотите переложить книги на полку. Первой вы возьмете в руки самую верхнюю книгу &amp;mdash; ту, которую положили в стопку последней.
По аналогии работает структура данных **стек**. Он позволяет добавлять элементы, а также доставать их в порядке, обратном тому, в котором вы их клали.
&gt;
&gt; В памяти компьютера есть область, также называемая стеком, потому что механизм хранения данных в ней выстрое по такому же принципу.
</code></pre>
