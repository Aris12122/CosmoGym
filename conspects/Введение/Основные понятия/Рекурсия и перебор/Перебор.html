<h1 id="рекурсия-и-перебор">Рекурсия и перебор</h1>
<h2 id="когда-полезен-перебор">Когда полезен перебор</h2>
<p>Некоторые задачи можно решить при помощи перебора всех возможных вариантов ответа. Часто такое решение достаточно медленное (ведь вариантов решения может оказаться очень много!), но при этом точно правильное, так как мы проверяем все возможные случаи. Часто на то, что задачу можно решить перебором, указывают небольшие ограничения на входные данные.</p>
<p>С другой стороны, иногда при помощи перебора можно решить задачу частично. Для лучшего понимания посмотрим на схемы оценки задач.</p>
<h2 id="схемы-оценки-задач-на-олимпиадах">Схемы оценки задач на олимпиадах</h2>
<p>На олимпиадах вы столкнетесь с тремя самыми распространенными схемами:</p>
<ol>
<li><p><strong>Потестовая оценка</strong> &mdash; за каждый пройденный вашей программой тест вы получаете какое-то количество баллов. (Школьный и Муниципальный этап ВСОШ, МОШ и некоторые другие олимпиады)</p>
</li>
<li><p><strong>Баллы за подгруппы</strong>. Оценка задачи разбивается на несколько частей в зависимости от ограничений на входные данные. (Почти все перечневые олимпиады, Региональный и Заключительный этапы ВСОШ). Такая проверка позволяет получить частичные баллы за решение, если у вас есть верный, но не эффективный алгоритм.</p>
<p> <a href="https://ibb.co/S0VTrxM"><img src="https://i.ibb.co/sQsSHPN/limits.png" alt="limits" border="0"></a></p>
</li>
<li><p><strong>Баллы за полное решение</strong> &mdash; задача зачтена, только если прошла все тесты. (Codeforces, ACMP, ВКОШП)</p>
</li>
</ol>
<p>Поэтому, если вы не знаете, как решить задачу полностью, важно написать хотя бы медленнное, но правильное 
решение. Чаще всего &mdash; это решение перебором.</p>
<h3>Простой перебор</h3>

<p>Давайте решим перебором следующие задачи. (Пусть в каждой из них ограничение по времени &mdash; $1$ секунда).</p>

<p><strong>1. Даны два целых числа $n$ и $k$. Найдите количество чисел от $1$ до $n$, кратных $k$.</strong></p>

<p>Самое простое решение &mdash; переберем все числа в цикле for и будем добавлять $1$ в сумму при встрече с каждым подходящим числом.</p>

<pre>
<code class="language-py">n, k = map(int, input().split()) 
Sum = 0                         
for i in range(1, n + 1):
    if i % k == 0:
        Sum += 1
print(Sum)
</code></pre>

<p>Решение работает за время $O(n)$, то есть на <em>Python</em> мы можем позволить себе ограничения на $n$ до $10^6$, на <em>С++</em> &mdash; до $10^8$.</p>

<p><strong>2. Дан список $A$, содержащий $n$ целых положительных чисел. Найдите пару элементов $A_i$ и $A_j$ с наибольшим произведением, такую, что их сумма кратна $3$.</strong></p>

<p>Если мы не знаем, как эффективно решить эту задачу, то можем просто перебрать все пары чисел и выбрать такую, которая удовлетворяет условиям.</p>

<pre>
<code class="language-py">Max = 0
MaxA = 0
MaxB = 0
for i in range(len(A)):
    for j in range(len(A)):
        if i == j:
            continue
        if A[i] * A[j] &gt; Max and (A[i] + A[j]) % 3 == 0:
            Max = A[i] * A[j]
            MaxA = A[i]
            MaxB = A[j]
print(MaxA, MaxB)
</code></pre>

<p>Данная программа работает за $O(n^2)$, а значит, на <em>Python</em> она будет проходить по времени для $n \le 10^3$, на <em>C++</em> &mdash; для $n \le 10^4$</p>

<p><strong>3. На плоскости дано $n$ точек $A_i$ с координатами $(x_i, y_i)$. В массив $x$ записаны все $x_i$, в массив y &mdash; все $y_i$. Сколько четверок из них образуют прямоугольники?</strong></p>

<p>Пусть у нас есть функция $rect$*, которая возвращает значение <strong>True</strong>, если $4$ точки образуют треугольник, и <strong>False</strong> в противном случае.</p>

<p>Переберем точки $(x1, y1)$, $(x2, y2)$, $(x3, y3)$, $(x4, y4)$ и проверим для каждой из них. Не забудем поделить полученную сумму на $24$ (это $4!$) &mdash; ровно столько раз мы посчитали каждый из прямоугольников, так как мы перебрали все перестановки каждой четверки точек.</p>

<pre>
<code class="language-py">sum = 0
n = 4
for i in range(n):
    for j in range(n):
        for k in range(n):
            for l in range(n):
                if rect(x[i], y[i], x[j], y[j], x[k], y[k], x[l], y[l]):
                    sum += 1
print(sum // 24)
</code></pre>

<blockquote>
<p>*Данная функция работает за $O(1)$. В качестве упражнения можете ее написать и получить дополнительные баллы за курс.</p>
</blockquote>

<p>Ассимптотка данного решения &mdash; $O(n^4)$. На <em>C++</em> мы смогли бы решить такую задачу для $n \le 100$.</p>
<h3>Оптимизация простых переборов</h3>

<p>Понятно, что чаще всего асимптотика, которую имеет перебор, нас не устраивает. Скорее всего это говорит о том, что нужно написать более эффективный алгоритм. Однако, в некоторых случаях оптимизация перебора позволяет пройти на подгруппу больше.</p>

<ul>
	<li>
	<p><strong>Не будем перебирать лишнее</strong>. Обратимся ко второй задаче: выпишем в первый столбец все пары индексов, которые мы рассматриваем в первоначальном решении. Всего проверяем $n^2$ пар.</p>

	<p>А теперь заметим, что например пара ($1, 2$) и ($2, 1$) &mdash; это одно и то же, а пару ($1, 1$), как и любую другую, содержащую два одинаковых индекса, мы всегда пропускаем. Тогда не будем перебирать лишние пары &mdash; зафиксируем, что всегда будет выполнено $i &lt; j$ и выпишем получившиеся пары во второй столбец.</p>

	<pre>
<code>  1, 1    1, 2
  1, 2    1, 3
  1, 3    2, 3
  2, 1    
  2, 2   
  2, 3    
  3, 1
  3, 2
  3, 3
</code></pre>

	<p>Мы сильно сократили перебор: вместо $n^2$ действий произвели $n * (n - 1) / 2$.</p>
	</li>
	<li>
	<p><strong>Идейная оптимизация.</strong> Посмотрим на последнюю задачу. Справедливо, что и по трем точкам мы сможем понять, прямоугольник ли перед нами, так как четвертая будет однозначно задаваться. Тогда можно ограничиться $6$ циклами для перебора $(x1, y1), (x2, y2), (x3, y3)$, а затем проверить, есть ли в нашем списке искомая четвертая точка (это можно сделать за $O(log_2(n))$ при помощи $set$).</p>
	</li>
</ul>

<p>Но мы можем упростить задачу еще, так как прямоугольник можно задать и двумя координатами противоположных углов!</p>

<p>Научились решать задачу за гораздо меньшее время, улучшив асимптотику с $O(n^4)$ до $O(n^2 * log_2(n))$.</p>
<h2>Перебор всех перестановок</h2>

<h3>Идея</h3>

<blockquote>
<p><strong>Перестановка</strong> --- это множество из $n$ чисел от $1$ до $n$, каждое из которых встречается ровно один раз.</p>
</blockquote>

<p>Например, все возможные перестановки для $n = 3$:</p>

<p><strong>123, 132, 213, 231, 312, 321</strong></p>

<p>Всего перестановок из $n$ элементов $n!$ (факториал числа $n$). При $n = 3$ их всего $3! = 6$. При $n = 12$ фаториал достигает уже $479001600$, то есть примерно $4.79 \cdot 10^8$.</p>

<p>Из <a href="" rel="noopener noreferrer nofollow">урока по ассимптотике</a> вспомним, что на с++ можно выполнить примерно $10^8$ операций в секунду. Поэтому можно себе позволить перебор всех перестановок только для очень малых значений $n$!</p>

<h3>Реализация</h3>

<p>Можно представить себе перестановку не просто чисел, а элементов какого-то множества, например букв в слове. Просто мысленно присвоим всем буквам порядковый номер, и каждой перестановке номеров сопоставим перестановку соответвующих им букв.</p>

<p>Так, все перестановки строки <strong>aba</strong>:</p>

<p><strong>aba, aab, baa</strong></p>

<p>Перестановок получилось меньше $6$, потому что некоторые буквы совпадают, и даже стоя на различных позициях дают одинаковые слова.</p>

<p>В языке c++ имеются встроенные функции, позволяющие получать следующую либо предыдущую перестановку --- <strong>next_permutation</strong> и <strong>prev_permutation</strong>.</p>

<p>Посмотрим на пример их использования.</p>

<pre>
<code class="language-cpp">string letters = 'abc';
do{

    cout &lt;&lt; letters &lt;&lt; endl;

}while(next_permutation(letters.begin(), letters.end()));
</code></pre>
