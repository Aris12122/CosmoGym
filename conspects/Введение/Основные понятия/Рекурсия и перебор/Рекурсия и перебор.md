# Рекурсия и перебор

## Переборы


## Рекурсия

### Как работает рекурсивная функция?

Для начала познакомимся с таким понятием, как **рекуррентная формула**.

> **Рекуррентная формула** &mdash; формула, в которой каждое последующее значение зависит от предыдущего (или нескольких предыдущих). 

Например, уже знакомые нам *числа Фибоначчи* задаются следующей формулой:

$F_n = F_{n - 1} + F_{n - 2}$

Рекуррентной формулой задается и *факториал* числа $n$:

$n! = (n - 1)! * n$

Формально, **рекурсивная функция** реализует вычисление значения по рекуррентной формуле или реализует последовательность действий, рекуррентно зависящих друг от друга.

Чаще можно встретиться со следующим определением: 
> **Pекурсивная функция** &mdash; это такая функция, которая вызывает саму себя.

### Бесконечная рекурсия

Вы уже знакомы с бесконечным циклом. Например, следующий код будет бесконечно* выводить число $1$.

```py
while True:
    print(1)
```

Аналогично можно представить себе рекурcивную функцию, которая бесконечно вызывает саму себя:

```py
def F(x):
    return F(x)
```

Как избежать такого? Всегда необходимо иметь условие выхода из рекурсии. Например, если мы посмотрим на следующий код, вычисляющий факториал числа $n$.

```py
def Fact(n):
    if n <= 1:
        return 1
    else:
        return n * Fact(n - 1)
```
Рассмотрим, что произойдет, если мы вызовем $F(3)$.

* $3 \gt 1$, возвращаем $3 \cdot Fact(3 - 1)$.
* $Fact(3 - 1)$ &mdash; это $F(2)$. При этом $2 \gt 1$, возвращаем $2 \cdot Fact(2 - 1)$.
* $Fact(2 - 1)$ &mdash; это $Fact(1)$. При этом $1 \le 1$. Тогда мы не вызываем нашу функцию $Fact$ еще раз, а просто возвращаем число $1$.

C этого момента мы не будем больше вызывать фунцию $Fact$ и начнется этап рефлексии (вставить картинку)

### Пример: дерево рекурсии и вычисление чисел Фибоначчи

Научимся вычислять $n$-е число Фибоначчи. Для начала еще раз вспомним формулу:

> $F_0$ = 1
>
> $F_1$ = 1
>
> $F_n = F_{n - 1} + F_{n - 2}$

Функцию, которая будет выполнять вычисление числа Фибонначчи, назовем $F(x)$. Сразу заметим, что значение первых двух чисел Фибоначчи нам известны, они являются константами.

Версия для Python

```py
def F(x):
    if x <= 0:
        return 1
    if x == 1:
        return 1
    return F(x - 1) + F(x - 2)

print(F(4))
```
Версия для С++

```cpp
int F(int x){
    if(x <= 0) return 1;
    if(x == 1) return 1;
    return F(x - 1) + F(x - 2);
}

int main(){
    cout << F(4);
}
```

Для большего удобства сопоставляйте пункты, написанные ниже, с картинкой.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/VQhqbXF/graph-3.png" alt="graph-3" border="0"></a>

* Мы хотим посчитать $F(4)$. Для этого нужно посчитать $F(3) + F(2)$. Так как $F(3)$ стоит в нашей сумме первым, то посчитаем сначала его.
* Вызвав $F(3)$, понимаем, что нужно посчитать $F(2) + F(1)$. Первое слагаемое &mdash; $F(2)$ &mdash; посчитаем его.
* Вызываем $F(2)$. Теперь нужно посчитать $F(1) + F(0)$.
* Вызываем $F(1)$. Оно не зависит от предыдущих значений и всегда равно $1$. Мы спустились до самого низа и теперь начинаем подниматься. Зачем мы считали $F(1)$? Потому что оно было слагаемым суммы $F(1) + F(0)$. Значит, теперь мы считаем $F(0)$.
* $F(0)$ также всегда возвращает $1$. И мы снова поднимаемся на шаг назад. $F(2) = F(1) + F(0) = 1 + 1 = 2$. Мы посчитали значение для $F(2)$. А оно было нужно, чтобы посчитать $F(3) = F(2) + F(1)$. Первое слагаемое известно &mdash; считаем второе &mdash; вызываем $F(1)$.

Дальнейший алгоритм будет аналогичен &mdash; спускаемся по "ветке", пока не достигаем такого значения, которое не зависит от предыдущего &mdash; тогда возвращаемся на шаг назад к предыдущему разветвлению.


### Когда может понадобиться рекурсия?


Предположим, что мы не знаем, сколько вложенных циклов нам понадобится. Или знаем, но их будет очень много.
Например, перед нами стоит такая задача: 

> **Выведите все строки длины  $10$, состоящие из букв $a, b, c$**.

Конечно, мы можем написать $10$ вложенных циклов: