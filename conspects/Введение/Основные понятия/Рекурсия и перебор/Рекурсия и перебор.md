# Рекурсия и перебор

## Переборы

Некоторые задачи можно решить при помощи перебора всех возможных вариантов. Часто такое решение достаточно медленное, но при этом точно правильное, так как мы проверяем все варианты.

На олимпиадах вы столкнетесь с тремя самыми распространенными схемами:

1. **Потестовая оценка** &mdash; за каждый пройденный вашей программой тест вы получаете какое-то количество баллов. (Школьный и Муниципальный этап ВСОШ, МОШ и некоторые другие олимпиады)
2. **Баллы за подгруппы**. Оценка задачи разбивается на несколько частей в зависимости от ограничений на входные данные. (Почти все перечневые олимпиады, Региональный и Заключительный этапы ВСОШ). Такая проверка позволяет получить частичные баллы за решение, если у вас есть верный, но не эффективный алгоритм.

<a href="https://ibb.co/S0VTrxM"><img src="https://i.ibb.co/sQsSHPN/limits.png" alt="limits" border="0"></a>

3. **Баллы за полное решение** &mdash; задача зачтена, только если прошла все тесты. (Codeforces, ACMP, ВКОШП)

Поэтому, если вы не знаете, как решить задачу полностью, важно написать хотя бы медленнное, но правильное 
решение. Чаще всего &mdash; это решение перебором.

### Простой перебор

Давайте решим перебором следующие задачи. (Пусть в каждой из них ограничение по времени &mdash; $1$ секунда).
___

**1. Даны два целых числа $n$ и $k$. Найдите количество чисел от $1$ до $n$, кратных $k$.**

Самое простое решение &mdash; переберем все числа в цикле for и будем добавлять $1$ в сумму при встрече с каждым подходящим числом.

```py
n, k = map(int, input().split()) 
Sum = 0                         
for i in range(1, n + 1):
    if i % k == 0:
        Sum += 1
print(Sum)
```

Решение работает за время $O(n)$, то есть на *Python* мы можем позволить себе ограничения на $n$ до $10^6$, на *С++* &mdash; до $10^8$.
___
**2. Дан список $A$, содержащий $n$ целых положительных чисел. Найдите пару элементов $A_i$ и $A_j$ с наибольшим поизведением, такую, что их сумма кратна $3$.**

Если мы не знаем, как эффективно решить эту задачу, то можем просто перебрать все пары чисел и выбрать такую, которая удовлетворяет условиям.

```py
Max = 0
MaxA = 0
MaxB = 0
for i in range(len(A)):
    for j in range(len(A)):
        if i == j:
            continue
        if A[i] * A[j] > Max and (A[i] + A[j]) % 3 == 0:
            Max = A[i] * A[j]
            MaxA = A[i]
            MaxB = A[j]
print(MaxA, MaxB)
```

Данная программа работает за $O(n^2)$, а значит, на *Python* она будет проходить по времени для  $n \le 10^3$, на *C++* &mdash; для $n \le 10^4$
___
**3. На плоскости дано $n$ точек $A_i$ с координатами $(x_i, y_i)$. В массив $x$ записаны все $x_i$, в массив y &mdash; все $y_i$. Сколько четверок из них образуют прямоугольники?**

Пусть у нас есть функция $rect$*, которая возвращает значение **true**, если $4$ точки образуют треугольник, и **false** в противном случае.

Переберем точки $(x1, y1)$, $(x2, y2)$, $(x3, y3)$, $(x4, y4)$ и проверим для каждой из них. Не забудем поделить полученную сумму на $24$ (это $4!$) &mdash; ровно столько раз мы посчитали каждый из прямоугольников, так как мы перебрали все перестановки каждой четверки точек.

```py
sum = 0
n = 4
for i in range(n):
    for j in range(n):
        for k in range(n):
            for l in range(n):
                if rect(x[i], y[i], x[j], y[j], x[k], y[k], x[l], y[l]):
                    sum += 1
print(sum // 24)
```

> *Данная функция работает за $O(1)$. В качестве упражнения можете ее написать и получить дополнительные баллы за курс.
</spoiler>

Ассимптотка данного решения &mdash; $O(n^4)$. На *C++* мы смогли бы решить такую задачу для $n \le 100$.

### Оптимизация простых переборов

Понятно, что чаще всего асимптотика, которую имеет перебор, нас не устраивает. Скорее всего это говорит о том, что нужно написать более эффективный алгоритм. Однако, в некоторых случаях оптимизация перебора позволяет пройти на подгруппу больше.

* **Не будем перебирать лишнее**. Обратимся ко второй задаче: выпишем в первый столбец все пары индексов, которые мы рассматриваем в первоначальном решении. Всего проверяем $n^2$ пар.

     А теперь заметим, что например пара ($1, 2$) и ($2, 1$) &mdash; это одно и то же, а пару ($1, 1$), как и любую другую, содержащую два одинаковых индекса, мы всегда пропускаем. Тогда не будем перебирать лишние пары &mdash; зафиксируем, что всегда будет выполнено $i < j$ и выпишем получившиеся пары во второй столбец.

    ~~~~
    1, 1    1, 2
    1, 2    1, 3
    1, 3    2, 3
    2, 1    
    2, 2   
    2, 3    
    3, 1
    3, 2
    3, 3
    ~~~~

    Мы сильно сократили перебор: вместо $n^2$ действий произвели $n * (n - 1) / 2$.

* **Идейная оптимизация.** Посмотрим на последнюю задачу. Справедливо, что и по трем точкам мы сможем понять, прямоугольник ли перед нами, так как четвертая будет однозначно задаваться. Тогда можно ограничиться $6$ циклами для перебора $(x1, y1), (x2, y2), (x3, y3)$, а затем проверить, есть ли в нашем списке искомая четвертая точка (это можно сделать за $O(log_2(n))$ при помощи $set$).

Но мы можем упростить задачу еще, так как прямоугольник можно задать и двумя координатами противоположных углов! 
Научились решать задачу за гораздо меньшее время, улучшив асимптотику с $O(n^4)$ до $O(n^2 * log_2(n))$.

## Перебор всех перестановок

### Перебор всех перестановок: идея

> **Перестановка** --- это множество из $n$ чисел от $1$ до $n$, каждое из которых встречается ровно один раз.

Например, все возможные перестановки для $n = 3$:

**123, 132, 213, 231, 312, 321**

Всего перестановок из $n$ элементов $n!$ (факториал числа $n$). При $n = 3$ их всего $3! = 6$. При $n = 12$ фаториал достигает уже $479001600$, то есть примерно $4.79 \cdot 10^8$. 

Из [урока по ассимптотике]() вспомним, что на с++ можно выполнить примерно $10^8$ операций в секунду. Поэтому можно себе позволить перебор всех перестановок только для очень малых значений $n$!

### Перебор всех перестановок: реализация

Можно представить себе перестановку не просто чисел, а элементов какого-то множества, например букв в слове. Просто мысленно присвоим всем буквам порядковый номер, и каждой перестановке номеров сопоставим перестановку соответвующих им букв. 

Так, все перестановки строки **aba**:

**aba, aab, baa**

Перестановок получилось меньше $6$, потому что некоторые буквы совпадают, и даже стоя на различных позициях дают одинаковые слова.

В языке c++ имеются встроенные функции, позволяющие получать следующую либо предыдущую перестановку --- **next_permutation** и **prev_permutation**.

Посмотрим на пример их использования.

```cpp
string letters = 'abc';
do{

    cout << letters << endl;

}while(next_permutation(letters.begin(), letters.end()));
```



## Перебор подмасок: идея

## Перебор подмасок: реализация**


## Рекурсия

### Как работает рекурсивная функция?

Для начала познакомимся с таким понятием, как **рекуррентная формула**.

> **Рекуррентная формула** &mdash; формула, в которой каждое последующее значение зависит от предыдущего (или нескольких предыдущих). 

Например, уже знакомые нам *числа Фибоначчи* задаются следующей формулой:

$F_n = F_{n - 1} + F_{n - 2}$

Рекуррентной формулой задается и *факториал* числа $n$:

$n! = (n - 1)! * n$

Формально, **рекурсивная функция** реализует вычисление значения по рекуррентной формуле или реализует последовательность действий, рекуррентно зависящих друг от друга.

Чаще можно встретиться со следующим определением: 
> **Pекурсивная функция** &mdash; это такая функция, которая вызывает саму себя.

### Бесконечная рекурсия

Вы уже знакомы с бесконечным циклом. Например, следующий код будет бесконечно* выводить число $1$.

```py
while True:
    print(1)
```

Аналогично можно представить себе рекурcивную функцию, которая бесконечно вызывает саму себя:

```py
def F(x):
    return F(x)
```

Как избежать такого? Всегда необходимо иметь условие выхода из рекурсии. Например, если мы посмотрим на следующий код, вычисляющий факториал числа $n$.

```py
def Fact(n):
    if n <= 1:
        return 1
    else:
        return n * Fact(n - 1)
```
Рассмотрим, что произойдет, если мы вызовем $F(3)$.

* $3 \gt 1$, возвращаем $3 \cdot Fact(3 - 1)$.
* $Fact(3 - 1)$ &mdash; это $F(2)$. При этом $2 \gt 1$, возвращаем $2 \cdot Fact(2 - 1)$.
* $Fact(2 - 1)$ &mdash; это $Fact(1)$. При этом $1 \le 1$. Тогда мы не вызываем нашу функцию $Fact$ еще раз, а просто возвращаем число $1$.

C этого момента мы не будем больше вызывать фунцию $Fact$ и начнется этап рефлексии (вставить картинку)

### Пример: дерево рекурсии и вычисление чисел Фибоначчи

Научимся вычислять $n$-е число Фибоначчи. Для начала еще раз вспомним формулу:

> $F_0$ = 1
>
> $F_1$ = 1
>
> $F_n = F_{n - 1} + F_{n - 2}$

Функцию, которая будет выполнять вычисление числа Фибонначчи, назовем $F(x)$. Сразу заметим, что значение первых двух чисел Фибоначчи нам известны, они являются константами.

Версия для Python

```py
def F(x):
    if x <= 0:
        return 1
    if x == 1:
        return 1
    return F(x - 1) + F(x - 2)

print(F(4))
```
Версия для С++

```cpp
int F(int x){
    if(x <= 0) return 1;
    if(x == 1) return 1;
    return F(x - 1) + F(x - 2);
}

int main(){
    cout << F(4);
}
```

Для большего удобства сопоставляйте пункты, написанные ниже, с картинкой.

<a href="https://imgbb.com/"><img src="https://i.ibb.co/VQhqbXF/graph-3.png" alt="graph-3" border="0"></a>

* Мы хотим посчитать $F(4)$. Для этого нужно посчитать $F(3) + F(2)$. Так как $F(3)$ стоит в нашей сумме первым, то посчитаем сначала его.
* Вызвав $F(3)$, понимаем, что нужно посчитать $F(2) + F(1)$. Первое слагаемое &mdash; $F(2)$ &mdash; посчитаем его.
* Вызываем $F(2)$. Теперь нужно посчитать $F(1) + F(0)$.
* Вызываем $F(1)$. Оно не зависит от предыдущих значений и всегда равно $1$. Мы спустились до самого низа и теперь начинаем подниматься. Зачем мы считали $F(1)$? Потому что оно было слагаемым суммы $F(1) + F(0)$. Значит, теперь мы считаем $F(0)$.
* $F(0)$ также всегда возвращает $1$. И мы снова поднимаемся на шаг назад. $F(2) = F(1) + F(0) = 1 + 1 = 2$. Мы посчитали значение для $F(2)$. А оно было нужно, чтобы посчитать $F(3) = F(2) + F(1)$. Первое слагаемое известно &mdash; считаем второе &mdash; вызываем $F(1)$.

Дальнейший алгоритм будет аналогичен &mdash; спускаемся по "ветке", пока не достигаем такого значения, которое не зависит от предыдущего &mdash; тогда возвращаемся на шаг назад к предыдущему разветвлению.


### Когда может понадобиться рекурсия?


Предположим, что мы не знаем, сколько вложенных циклов нам понадобится. Или знаем, но их будет очень много.
Например, перед нами стоит такая задача: 

> **Выведите все строки длины  $10$, состоящие из букв $a, b, c$**.

Конечно, мы можем написать $10$ вложенных циклов, но такое решение займет много времени и места в коде, в нем легко ошибиться. Тем более, смысл каждого цикла одинаков &mdash; выбираем индекс элемента в строке.

Тогда давайте напишем рекурсивную функцию, которая просто $10$ раз вызывает такой вложенный цикл! 

### Оптимизация рекурсии: мемоизация

Для $n=6$ дерево стало уже очень большим. При этом, многие значения нам приходится считать по несколько раз!

<a href="https://ibb.co/zFNrhtn"><img src="https://i.ibb.co/gd63Mcj/graph-6.png" alt="graph-6" border="0"></a>

Прием, позволяющий уменьшить количество вызовов, называется мемоизация (без Р). Заведем массив $count$ на $n$ элементов, в котором $count[0] = count[1] = 1$. Если мы уже посчитали $F(n)$, то заполним $count[n] = F(n)$. Каждый раз при входе в функцию будем проверять, заполнено ли уже $count[n]$, и если да, то просто будем возвращать его значение:

~~~~
def F(x):
    if count[x]:
        return count[x]
    return F(x - 1) + F(x - 2)

print(F(6))
~~~~

### Рекурсивные переборы**
