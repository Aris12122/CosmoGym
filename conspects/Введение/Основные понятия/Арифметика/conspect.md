# Арифметика

## Целочисленные типы данных

При решении задач почти всегда приходится хранить и обрабатывать данные. Для хранения целых чисел в C++ используются типы int, long long, short и другие. Чаще всего вы будете пользоваться типами int и long long. Они отличаются диапазоном значений. 

Тип int может хранить числа примерно от $-2 \cdot 10^9$ (минус двух миллиардов) до $2 \cdot 10^9$.

В то время как long long имеет диапазон примерно от $-9 \cdot 10^{18}$ до $9 \cdot 10^{18}$

Также в плюсах есть так называемые беззнаковые типы данных. Они отличаются тем, что не принимают отрицательных значений, соответственно максимальное положительное значение, которого они могут достигать выше.

Например, unsigned int имеет диапазон от $0$ до примерно $4 \cdot 10^9$.

В языке python реализована так называемая длинная арифметика, так что как четкого диапазона значений у целых чисел там нет и в большинстве случаев можно не думать об этом.

Помимо хранения, также необходимо уметь и выполнять различные операции с целыми числами.

[Подробнее в python](https://docs-python.ru/tutorial/osnovnye-vstroennye-tipy-python/tip-dannyh-int-tselye-chisla/)

[Подробнее в C++](https://ravesli.com/urok-31-tselochislennyj-tip-dannyh-integer/)

***

## Операции с целыми числами

Вы уже знаете, что есть такие операции, как сложение, вычитание, умножение и деление (целочисленное: "/ в C++" и "// в python"). Также есть операция взятие остатка по какому-то модулю.

### Целочисленное деление 

В математике обозначается как $\lfloor \frac{a}{b} \rfloor$ &mdash; деление с округлением вниз.

$\lfloor \frac{a}{b} \rfloor = k$, где $k$ &mdash; наибольшее число такое, что $b \cdot k \le a$.

Для положительных чисел можно понимать это так: мы делим число $a$ на $b$ и отбрасываем дробную часть.

Например: $\frac{27}{7} = 3.86..$ , тогда $\lfloor \frac{27}{7} \rfloor = 3$.

### Остаток от деления

По определению, если есть числа $a$ и $b$, а $\lfloor \frac{a}{b} \rfloor = k$, то $m = a - b \cdot k$ &mdash; остаток от деления числа $a$ на $b$.

Заметьте, что из определения целочисленного деления $0 \le m < b$. Попробуйте понять, почему так происходит.

И пишут $a$ mod $b = m$. В C++ и python за это отвечает операция "%".

Например, запись: $27$ mod $7 = 1$ читается, как: остаток от деления $27$-ти на $7$ равен $6$.

Так как $\lfloor \frac{27}{7} \rfloor = 3$ и $27 - 7 \cdot 3 = 6$.

Попробуйте запустить эти строчки у себя на компьютере на python и C++ соответственно:

```python
print(27 % 7)
```

```c
cout << 27 % 7;
```

[Подробнее](https://ru.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic)

*** 

## Вещественные типы данных

Иногда приходится сталкиваться с вещественными числами. Про них мы поговорим позже, а пока вам достаточно знать, что:

* в python операция "/" отвечает за вещественное деление и как его результат вы получите вещественное число.
* в C++ если оба числа являются целыми, то операция "/" вернет целое число. Но если хотя бы одно из чисел является вещественным, тогда результатом станет вещественное число.
* В C++ вещественные типы данных: float, double, long double. Старайтесь использовать double или long double. 

```python
print(27 / 7) # вывод: 3.857142857142857
```

```c
cout << 27 / 7 << '\n';         // вывод: 3
cout << 27. / 7 << '\n';        // вывод: 3.85714
cout << 27 / 7. << '\n';        // вывод: 3.85714
cout << 27. / 7. << '\n';       // вывод: 3.85714
cout << double(27) / 7 << '\n'; // вывод: 3.85714
cout << double(27 / 7) << '\n'; // вывод: 3. (но результат --- вещественное число)
```

*** 

## Простые числа

Целое число $a$ называется множителем, или делителем целого числа $b$,
если $a$ делит $b$ ($b$ делится на $a$). Другими словами, число $a$ является множителем $b$, если остаток от деления числа $b$ на $a$ равен $0$. Например, множителями числа $24$ являются: $1, 2, 3, 4, 6, 8, 12$ и $24$.

```c
// В коде можно проверить, что число $a$ делит $b$ можно так:

if (b % a == 0) {
    // a является множителем b
} else {
    // a не является множителем b
}
```

Целое число $x > 1$ называется простым, если оно имеет ровно $2$ положительных множителя: $1$ и $x$. Число $1$ простым не является.

Первые простые числа: 2, 3, 5, 7, 11, 13, 17, 19, 23 ...

Проверим, является ли число $x$ простым. Для этого проверим, что все числа от $2$ до $x-1$ не являются множителями числа $x$.

```c
bool is_prime(int x) {
    for (int i = 2; i < x; i++) {
        if (x % i == 0) {
            return false;
        }
    }
    return x > 1; // так как простым может быть только число > 1
}
```

Для каждого целого числа $n > 1$ существует единственное разложение на простые множители:

$n = p_1^{a_1} \cdot p_2^{a_2} \cdot ...$ $ \cdot$ $p_k^{a_k} $,

где $p_1, p_2, ..., p_k$ &mdash; различные простые числа, а $a_1, a_2, ..., a_k$ &mdash; положительные целые числа.

### Решето Эратосфена

&mdash; это алгоритм нахождения всех простых чисел от $1$ до $n$. 

Основная идея:

Запишем все числа от $1$ до $n$ в один ряд и будем вычеркивать составные числа:

* Сначала те, которые делятся на $2$, кроме $2$;
* Затем те, которые делятся на $3$, кроме $3$;
* Так как $4$ мы уже вычеркнули, то и все числа, делящиеся на $4$ мы тоже вычеркнули;
* И так далее $\dots$

Реализация:

```python
Кристина напиши плез на питоне((

```

```cpp
vector<bool> is_prime(n + 1, true); // изначально все числа простые
is_prime[0] = is_prime[1] = false;

for (int i = 2; i <= n; i++) {
    if (!is_prime[i]) continue; // Если число не является простым, то мы его уже вычеркнули
    for (int j = i + i; j <= n; j += i) {
        is_prime[j] = false;
    }
}
```


[Подробнее](https://ru.algorithmica.org/cs/factorization/eratosthenes/)

***

## НОД и НОК


**Наибольшим общим делителем** (далее $НОД$) двух целых чисел $a$ и $b$ называется такое наибольшее целое число $d$, на которое $a$ и $b$ делятся без остатка. Этот факт обозначается так: $d = НОД(a, b)$. Если оба числа равны нулю, то положим $НОД(0, 0) = 0$.

**Наименьшим общим кратным** (далее $НОК$) двух целых чисел $a$ и $b$ называется наименьшее положительное целое число, кратное как $a$, так и $b$.

Несколько примеров: 

Найдем $НОД$ и $НОК$ чисел $12$ и $9$.

Делители числа $12$: $1, 2, 3, 4, 6, 12$.

Делители числа $9$: $1, 3, 9$.

Таким образом, наибольший общий делитель у них: $НОД(12, 9) = 3$.

Для нахождения $НОК$ воспользуемся программой по определению:

```c
int a = 12, b = 9;
for (int i = 12; ; i++) {
    if (a % i != 0) continue;
    if (b % i == 0) {
        // значит и a и b делятся на i и это минимальное возможное число

        cout << i << endl; // НОК(12, 9) = 36
        break;
    }
}
```

Для вычисления $НОК$ есть формула:

$НОК(a, b) = \frac{a \cdot b}{НОД(a, b)}$

Можем проверить на нашем примере:

$36 = \frac{9 \cdot 12}{3}$

[Подробнее](https://www.eolymp.com/ru/blogs/posts/16#:~:text=%D0%9D%D0%B0%D0%B8%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B8%D0%BC%20%D0%BE%D0%B1%D1%89%D0%B8%D0%BC%20%D0%B4%D0%B5%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D0%B5%D0%BC%20(%D0%B4%D0%B0%D0%BB%D0%B5%D0%B5%20%D0%9D%D0%9E%D0%94,0%2C%200)%20%3D%200)


## Алгоритм Евклида

&mdash; это эффективный способ вычисления $НОД(a, b)$. Он основан на формуле:

$НОД(a, b) = $
* $a$,              если $b = 0$.
* $НОД(b, a \% b)$, если $b \neq 0$ 

Реализация:

```c
int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
```
[Подробнее](https://e-maxx.ru/algo/euclid_algorithm)
