<h2>O-нотация</h2>

<h3>Зачем это нужно?</h3>

<p>Казалось бы, что для оценки времени работы можно просто физически измерять время, которое программа работает на разных входных данных. Здесь есть достаточное количество минусов:</p>

<ul>
	<li>
	<p>время выполнения программы на разном железе может быть разным, а тестируется все на одном;</p>
	</li>
	<li>
	<p>чтобы измерить время, придется запустить сам алгоритм, но иногда приходится оценивать алгоритмы, требующие часы или даже дни работы;</p>
	</li>
	<li>
	<p>время будет учитывать какие-то вспомогательные операции, которые на самом деле в текущей оценке не нужны;</p>
	</li>
	<li>
	<p>Зачастую основной задачей программиста становится оптимизировать алгоритм, выполнение которого займёт тысячи лет, до какого-нибудь адекватного времени работы. Поэтому хотелось бы уметь предсказывать, сколько времени займёт выполнение алгоритма ещё до того, как мы его запустим.</p>
	</li>
</ul>

<h3>Как же посчитать?</h3>

<p>Будем считать за одну операцию следующие (компьютер успевает выполнить $10^8$ таких операций за секунду, но иногда можно добиться и выполнения $10^9$ операций за секунду на быстрых процессорах, хотя на это не стоит рассчитывать):</p>

<ul>
	<li>
	<p>арифметические операции ($*$, $+$, $-$, $/$, битовые сдвиги);</p>
	</li>
	<li>
	<p>сравнение чисел;</p>
	</li>
	<li>
	<p>присваивание;</p>
	</li>
</ul>

<p>Мы можем попробовать точно оценить количество таких операций, которые выполняются в программе. Но в большинстве случаев такого подробного разбора всех действий не требуется. Если вы посчитаете, сколько операций сравнения происходит в разных квадратичных сортировках, то получите разные выражения, где главный член - это $N^2$, умноженное на некоторую константу плюс еще некоторая константа.</p>

<p>Хочется придумать способ упростить эти формулы так, чтобы:</p>

<p>1) не нужно было учитывать много информации, не очень сильно влияющей на итоговое время;</p>

<p>2) легко было оценивать время работы разных алгоритмов для больших чисел;</p>

<p>3) легко было сравнивать алгоритмы на предмет того, какой из них лучше подходит для тех или иных входных данных.</p>
