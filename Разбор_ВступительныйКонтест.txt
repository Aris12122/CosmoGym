Разбор этого же контеста вы можете посмотреть в видео формате и с примерами кода на python от Кристины [user:myav] по ссылке: //add link



<spoiler summary="A. Лифт">
Время для лифта определяется как $b \cdot (k-1 + n-1)$.  
При этом Миша поднимется на этаж $n$ за $a \cdot (n-1)$

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h> 
/*
    подключает все основные библиотеки, необходимые для олимпиадного программирования
    в компиляторе Visual C++ не работает, так что если пишете в Microsoft Visual Studio(не рекомендую), приходится подключать все библиотеки
    Соответственно когда сдаете где-либо задачу, выбирайте GNU G++17 или что-то похожее
    пример многострочного комментария
*/
using namespace std; //подключаем пространство имен std чтобы не писать std::cin и прочее

int main(){ // основная функция, при запуске выполняется именно она
    ios::sync_with_stdio(0); cin.tie(0); // магические строчки, ускоряющие считывание и вывод данных. Рекомендуется писать всегда, может когда-нибудь расскажу как это работает
    
    int n,k,a,b; cin>>n>>k>>a>>b;
    cout<<b * (n+k-2)<<' '<<a * (n-1);
    
    return 0;
}
~~~~~
</spoiler>

</spoiler>





<spoiler summary="B. Комната">
Написать то что просят

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    int w,l,h; cin>>w>>l>>h;

    if(min(l,w) / h >= 2 && max(l,w) / min(l,w) <= 2) cout<<"good";
    else cout<<"bad";

    return 0;
}
~~~~~
</spoiler>

</spoiler>





<spoiler summary="C. Bit++">
Заметим, что нам достаточно посмотреть на второй символ строки, чтобы узнать прибавлять или отнимать

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    int n; cin>>n;
    int res = 0;
    for (int i = 0; i < n; i++) {
        string s; cin>>s;
        if(s[1] == '+') res++;
        else res--;
    }
    cout<<res;
    return 0;
}
~~~~~
</spoiler>

</spoiler>





<spoiler summary="D. Солдат и бананы">
Стоимость всех бананов определяется как $sum = k \cdot (1 + 2 \ldots + w) = k \cdot \frac{(w+1) \cdot w}{2}$(Сумма арифметической прогрессии)
Тогда ответ $ans = max(0, sum - n)$

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;


int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    int k,n,w; cin>>k>>n>>w;
    int sum = k * (w*(w+1) / 2);
    cout<<max(0,sum - n);
    return 0;
}
~~~~~
</spoiler>

</spoiler>





<spoiler summary="E. Магниты">
Посчитать количество групп подрядидущих одиннаковых магнитов

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;
 
 
int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    int n, ans = 0; cin>>n;
    string pr = ""; //последняя строка, с которой будем сравнивать
    for (int i = 0; i < n; i++) {
        string s; cin>>s;
        if(s == pr) continue;
        ans++;
        pr = s;
    }
    cout<<ans;
    return 0;
}
~~~~~
</spoiler>

</spoiler>





<spoiler summary="F. Математика спешит на помощь">
Можно например посчитать кол-во $1, 2, 3$ отдельно, затем вывести новую сумму

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;

int cnt[3];//если объявлять целочисленный массив глобальным, он гарантированно будет содержать только нули, иначе в нем будет всякий мусор, можете потестировать

int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    string s; cin>>s;
    int n = (int)s.size(); //по умолчанию метод size() возвращает тип size_t, который является беззнаковым, так что его лучше приводить к типу int 

    for (int i = 0; i < n; i += 2) {
        cnt[s[i] - '1']++;
    }

    bool first = true; //нужно вывести + перед всеми цифрами, кроме первой
    for (int i = 0; i < 3; i++) {
        while(cnt[i]--){
            if(first){
                first = false;
                cout<<char(i + '1');
                /*
                    все символы имеют свое значение, цифры имеют подряд идущие значения
                    '5' == char('0' + 5), так как код '5' будет на 5 больше кода '0'
                    'c' == char('a' + 2) аналогично работает с латинскими буквами
                */

            }else cout<<'+'<<char(i + '1'); 
        }
    }
    return 0;
}
~~~~~
</spoiler>

</spoiler>






<spoiler summary="G. Петя и строки">
Идем по символам пока они одиннаковые, если нет, сразу понимаем какая строка меньше

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    string s,t; cin>>s>>t;
    int n = s.size();
    int ans = 0;
    for (int i = 0; i < n; i++) {
        if (s[i] >= 'A' && s[i] <= 'Z') s[i] = char(s[i] - 'A' + 'a'); // чтобы получить из заглавной буквы соответственную строчную можно вычесть код 'A' и прибавить 'a'
        if (t[i] >= 'A' && t[i] <= 'Z') t[i] = char(t[i] - 'A' + 'a');

        if (s[i] < t[i]) {
            ans = -1;
            break;
        } else if(t[i] < s[i]) {
            ans = 1;
            break;
        }
    }
    cout<<ans;
    return 0;
}
~~~~~
</spoiler>

</spoiler>




<spoiler summary="H. Футбол">
Узнать, есть ли в строке 7 одиннаковых символов подряд

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;
 
void yes(){
    cout<<"YES";
    exit(0); // принудительно завершает программу
}
 
int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    string s; cin>>s;
    int n = s.size();
    for (int i = 0; i+6 < n; i++) {
        int cnt = 1;
        for (int j = 1; j < 7; j++) {
            if(s[i+j] == s[i]) cnt++;
        }
        if(cnt == 7) yes();
    }
    cout<<"NO";
    return 0;
}
~~~~~
</spoiler>

</spoiler>




<spoiler summary="I. DZY любит строки">
Жадность: добавим в конец строки k символов таких, что их стоимость максимальна.

Доказательство: Если вставлять в середину строки, то если найдется элемент правее, стоимость которого меньше, можем поменять их местами и только улучшить ответ.
Если вставлять символ не максимальной стоимости, то можно поменять на максимальную и улучшить ответ

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;

int w[26];

int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    string s; cin>>s;
    int k, mx = 0; cin>>k;
    for (int i = 0; i < 26; i++) {
        cin>>w[i];
        mx = max(mx, w[i]);
    }

    int n = s.size(), ans = 0;
    for (int i = 0; i < n+k; i++) {
        if(i < n) ans += (i+1) * w[s[i]-'a'];//аналогично предыдущим случаям можем получить индекс буквы как int(letter - 'a') где letter - строчная латинская буква
        else ans += (i+1) * mx;
    }

    cout<<ans;
    return 0;
}
~~~~~
</spoiler>

</spoiler>




<spoiler summary="J. Конфеты">
$n = x \cdot (1 + 2 + 4 + \ldots + 2^{k-1}) = x \cdot (2^k - 1)$

$x = \frac{n}{2^k - 1}$

Так как $2^k$ растет очень быстро и уже при $k=30: 2^k \gt 10^9$, можем просто перебрать $k$ и проверить, подходящий ли $x$

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;

int solve(){
    int n; cin>>n;
    for(int k = 2; (1<<k)-1 <= n; k++){ //(1<<k) <=> 2^k
        int p = (1<<k)-1;
        if(n % p == 0) return n/p;
    }
    while(true); //проверяю, что ответ нашелся(иначе получу time limit)
}

int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    int t; cin>>t;
    while(t--) cout<<solve()<<'\n';
    return 0;
}
~~~~~
</spoiler>

</spoiler>




<spoiler summary="K. Медвежонок и поиск преступников">
Если на расстоянии $d$ количество клеток и количество преступников в них совпадает, Медвежонок их найдет

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;


int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    int n,a; cin>>n>>a;
    vector<int> t(n+1);
    for (int i = 1; i <= n; i++) {
        cin>>t[i];
    }

    int ans = 0;
    if (t[a]) ans++;
    for (int i = 1; i < max(a,n-a+1); i++) {
        int l = a-i, r = a+i;
        if (l < 1 && t[r]) ans++;
        else if (r > n && t[l]) ans++;
        else if(l >= 1 && r <= n && t[l] && t[r]) ans += 2; //когда мы применяем логическую операцию для числа x она возвращает true если x != 0 и false если x == 0
    }
    cout<<ans;
    return 0;
}
~~~~~
</spoiler>

</spoiler>  





<spoiler summary="L. Драконы">
отсортируем массив $v = (x_i,y_i)$ по возрастанию $x_i$, а затем жадно будем убивать монстров в таком же порядке

Доказательство: рассмотрим ответ: если он есть &mdash; это какой-то порядок в котором мы убиваем монстров, заметим теперь что если мы убили монстра $i$
а затем убили монстра $j$ и $x_i \gt x_j$, то мы можем поменять $i$ и $j$ местами, так как:

Пусть $cur$ &mdash; сила Кирито на момет убийства монстра $i$, то есть $cur \gt x_i$ , тогда если мы поменяем местами $i$ и $j$, то $cur \gt x_i \gt x_j$
и Кирито может убить j, его сила станет равна $cur + y_j \gt x_i$, так как $y_j \geq 0$. Тогда мы всегда меняем местами $i$ и $j$ если $x_i \gt x_j$ и получаем в итоге
отсортированный массив по $x$


<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;

#define F first //дефайны заменяют каждое вхождение F(левой части) в коде на first(правую часть)
#define S second //дефайны пишут для сокращения кода, далее будет множество примеров, также часто используются для собственных шаблонов


void no(){
    cout<<"NO\n";
    exit(0);
}

int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    int s,n; cin>>s>>n;
    vector<pair<int,int>> v(n);
    for (int i = 0; i < n; i++) {
        cin>>v[i].F>>v[i].S;
    }
    sort(v.begin(),v.end());

    for (int i = 0; i < n; i++) {
        if (s <= v[i].F) no();
        s += v[i].S;
    }

    cout<<"YES\n"; //для переноса строки можно использовать специальный символ '\n' или писать cout<<endl разницу объясню в видео
    return 0;
}
~~~~~
</spoiler>

</spoiler>  




<spoiler summary="M. Про таблицу умножения">
ограничения $n,m \leq 5 \cdot 10^5$ говорят о том что:

- есть числа порядка $10^{11}$ 

- не позволяют нам создать массив размерами n \times m, так как по памяти это займет $8байт(\text{long long}) \cdot nm \gt 10^{11}байт \approx 10^5Мб$, что, естественно, не укладывается в ограничения 

Используем бинарный поиск по ответу(более подробно этот алгоритм разберем позже): для числа $x$ теперь нужно узнать, сколько в таблице чисел $\leq x$;
Будем делать это за $O(n)$ следующим образом: для каждой строки $i$ кол-во чисел $\leq x = j$:

$j \cdot i \leq x$ 

$j \leq x / i$ 

Получаем: $j = min(m, x / i)$ 


Итоговая ассимптотика выходит $O(nlogn)$

<spoiler summary="Код">
~~~~~
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

ll n,m;

ll cnt(ll x){
    ll res = 0;
    for (int i = 1; i <= n; i++) { //2*j <= x, j <= x/2
        res += min(m,x / i);
    }
    return res;
}

int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    ll k; cin>>n>>m>>k;
    ll l = 0, r = n*m;
    while (r - l > 1){
        ll m = (r + l) >> 1;
        if (cnt(m) >= k) {
            r = m;
        } else {
            l = m;
        }
    }
    cout<<r<<endl;
    return 0;
}
~~~~~
</spoiler>

</spoiler>  


